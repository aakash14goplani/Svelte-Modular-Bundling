{"version":3,"mappings":"CAAqB,UAAoB,CACrC,MAAMA,EAAU,SAAS,cAAc,MAAM,EAAE,QAC/C,GAAIA,GAAWA,EAAQ,UAAYA,EAAQ,SAAS,eAAe,EAC/D,OAEJ,UAAWC,KAAQ,SAAS,iBAAiB,2BAA2B,EACpEC,EAAeD,CAAI,EAEvB,IAAI,iBAAkBE,GAAc,CAChC,UAAWC,KAAYD,EACnB,GAAIC,EAAS,OAAS,YAGtB,UAAWC,KAAQD,EAAS,WACpBC,EAAK,UAAY,QAAUA,EAAK,MAAQ,iBACxCH,EAAeG,CAAI,CAGvC,CAAK,EAAE,QAAQ,SAAU,CAAE,UAAW,GAAM,QAAS,EAAI,CAAE,EACvD,SAASC,EAAaC,EAAQ,CAC1B,MAAMC,EAAY,GAClB,OAAID,EAAO,YACPC,EAAU,UAAYD,EAAO,WAC7BA,EAAO,iBACPC,EAAU,eAAiBD,EAAO,gBAClCA,EAAO,cAAgB,kBACvBC,EAAU,YAAc,UACnBD,EAAO,cAAgB,YAC5BC,EAAU,YAAc,OAExBA,EAAU,YAAc,cACrBA,CACV,CACD,SAASN,EAAeD,EAAM,CAC1B,GAAIA,EAAK,GAEL,OACJA,EAAK,GAAK,GAEV,MAAMO,EAAYF,EAAaL,CAAI,EACnC,MAAMA,EAAK,KAAMO,CAAS,CAC7B,CACL,KC1CA,SAASC,GAAO,CAAG,CAEnB,SAASC,GAAOC,EAAKC,EAAK,CAEtB,UAAWC,KAAKD,EACZD,EAAIE,GAAKD,EAAIC,GACjB,OAAOF,CACX,CAIA,SAASG,GAAaC,EAASC,EAAMC,EAAMC,EAAQC,EAAM,CACrDJ,EAAQ,cAAgB,CACpB,IAAK,CAAE,OAAM,OAAM,SAAQ,MAAM,CACzC,CACA,CACA,SAASK,GAAIC,EAAI,CACb,OAAOA,EAAE,CACb,CACA,SAASC,IAAe,CACpB,OAAO,OAAO,OAAO,IAAI,CAC7B,CACA,SAASC,EAAQC,EAAK,CAClBA,EAAI,QAAQJ,EAAG,CACnB,CACA,SAASK,GAAYC,EAAO,CACxB,OAAO,OAAOA,GAAU,UAC5B,CACA,SAASC,EAAeC,EAAGC,EAAG,CAC1B,OAAOD,GAAKA,EAAIC,GAAKA,EAAID,IAAMC,GAAOD,GAAK,OAAOA,GAAM,UAAa,OAAOA,GAAM,UACtF,CACA,IAAIE,GACJ,SAASC,GAAcC,EAAaC,EAAK,CACrC,OAAKH,KACDA,GAAuB,SAAS,cAAc,GAAG,GAErDA,GAAqB,KAAOG,EACrBD,IAAgBF,GAAqB,IAChD,CAIA,SAASI,GAASC,EAAK,CACnB,OAAO,OAAO,KAAKA,CAAG,EAAE,SAAW,CACvC,CACA,SAASC,EAAeC,EAAOC,EAAM,CACjC,GAAID,GAAS,MAAQ,OAAOA,EAAM,WAAc,WAC5C,MAAM,IAAI,MAAM,IAAIC,6CAAgD,CAE5E,CACA,SAASC,GAAUF,KAAUG,EAAW,CACpC,GAAIH,GAAS,KACT,OAAO5B,EAEX,MAAMgC,EAAQJ,EAAM,UAAU,GAAGG,CAAS,EAC1C,OAAOC,EAAM,YAAc,IAAMA,EAAM,YAAW,EAAKA,CAC3D,CACA,SAASC,EAAgBL,EAAO,CAC5B,IAAIM,EACJ,UAAUN,EAAOO,GAAKD,EAAQC,CAAC,EAAC,EACzBD,CACX,CACA,SAASE,EAAoBC,EAAWT,EAAOU,EAAU,CACrDD,EAAU,GAAG,WAAW,KAAKP,GAAUF,EAAOU,CAAQ,CAAC,CAC3D,CACA,SAASC,GAAYC,EAAYC,EAAKC,EAAS9B,EAAI,CAC/C,GAAI4B,EAAY,CACZ,MAAMG,EAAWC,GAAiBJ,EAAYC,EAAKC,EAAS9B,CAAE,EAC9D,OAAO4B,EAAW,GAAGG,CAAQ,CAChC,CACL,CACA,SAASC,GAAiBJ,EAAYC,EAAKC,EAAS9B,EAAI,CACpD,OAAO4B,EAAW,IAAM5B,EAClBX,GAAOyC,EAAQ,IAAI,MAAO,EAAEF,EAAW,GAAG5B,EAAG6B,CAAG,CAAC,CAAC,EAClDC,EAAQ,GAClB,CACA,SAASG,GAAiBL,EAAYE,EAASI,EAAOlC,EAAI,CACtD,GAAI4B,EAAW,IAAM5B,EAAI,CACrB,MAAMmC,EAAOP,EAAW,GAAG5B,EAAGkC,CAAK,CAAC,EACpC,GAAIJ,EAAQ,QAAU,OAClB,OAAOK,EAEX,GAAI,OAAOA,GAAS,SAAU,CAC1B,MAAMC,EAAS,GACTC,EAAM,KAAK,IAAIP,EAAQ,MAAM,OAAQK,EAAK,MAAM,EACtD,QAASG,EAAI,EAAGA,EAAID,EAAKC,GAAK,EAC1BF,EAAOE,GAAKR,EAAQ,MAAMQ,GAAKH,EAAKG,GAExC,OAAOF,CACV,CACD,OAAON,EAAQ,MAAQK,CAC1B,CACD,OAAOL,EAAQ,KACnB,CACA,SAASS,GAAiBC,EAAMC,EAAiBZ,EAAKC,EAASY,EAAcC,EAAqB,CAC9F,GAAID,EAAc,CACd,MAAME,EAAeZ,GAAiBS,EAAiBZ,EAAKC,EAASa,CAAmB,EACxFH,EAAK,EAAEI,EAAcF,CAAY,CACpC,CACL,CAKA,SAASG,GAAyBf,EAAS,CACvC,GAAIA,EAAQ,IAAI,OAAS,GAAI,CACzB,MAAMI,EAAQ,GACRY,EAAShB,EAAQ,IAAI,OAAS,GACpC,QAASQ,EAAI,EAAGA,EAAIQ,EAAQR,IACxBJ,EAAMI,GAAK,GAEf,OAAOJ,CACV,CACD,MAAO,EACX,CAmCA,SAASa,GAAgB/B,EAAOgC,EAAK1B,EAAO,CACxC,SAAM,IAAIA,CAAK,EACR0B,CACX,CAEA,SAASC,GAAiBC,EAAe,CACrC,OAAOA,GAAiB9C,GAAY8C,EAAc,OAAO,EAAIA,EAAc,QAAU9D,CACzF,CAuJA,SAAS+D,GAAOC,EAAQpE,EAAM,CAC1BoE,EAAO,YAAYpE,CAAI,CAC3B,CAoDA,SAASqE,GAAOD,EAAQpE,EAAMsE,EAAQ,CAClCF,EAAO,aAAapE,EAAMsE,GAAU,IAAI,CAC5C,CASA,SAASC,GAAOvE,EAAM,CAClBA,EAAK,WAAW,YAAYA,CAAI,CACpC,CACA,SAASwE,GAAaC,EAAYC,EAAW,CACzC,QAASpB,EAAI,EAAGA,EAAImB,EAAW,OAAQnB,GAAK,EACpCmB,EAAWnB,IACXmB,EAAWnB,GAAG,EAAEoB,CAAS,CAErC,CACA,SAAShE,GAAQuB,EAAM,CACnB,OAAO,SAAS,cAAcA,CAAI,CACtC,CAmBA,SAAS0C,GAAKC,EAAM,CAChB,OAAO,SAAS,eAAeA,CAAI,CACvC,CACA,SAASC,IAAQ,CACb,OAAOF,GAAK,GAAG,CACnB,CACA,SAASG,IAAQ,CACb,OAAOH,GAAK,EAAE,CAClB,CAiCA,SAASI,GAAK/E,EAAMgF,EAAW1C,EAAO,CAC9BA,GAAS,KACTtC,EAAK,gBAAgBgF,CAAS,EACzBhF,EAAK,aAAagF,CAAS,IAAM1C,GACtCtC,EAAK,aAAagF,EAAW1C,CAAK,CAC1C,CAgEA,SAAS2C,GAASvE,EAAS,CACvB,OAAO,MAAM,KAAKA,EAAQ,UAAU,CACxC,CAuIA,SAASwE,GAAUlF,EAAMmF,EAAK7C,EAAO8C,EAAW,CACxC9C,IAAU,KACVtC,EAAK,MAAM,eAAemF,CAAG,EAG7BnF,EAAK,MAAM,YAAYmF,EAAK7C,EAAO8C,EAAY,YAAc,EAAE,CAEvE,CA6EA,SAASC,GAAa3E,EAASuB,EAAMqD,EAAQ,CACzC5E,EAAQ,UAAU4E,EAAS,MAAQ,UAAUrD,CAAI,CACrD,CACA,SAASsD,GAAaC,EAAMC,EAAQ,CAAE,UAAU,GAAO,aAAa,EAAO,EAAG,GAAI,CAC9E,MAAMC,EAAI,SAAS,YAAY,aAAa,EAC5C,SAAE,gBAAgBF,EAAMG,EAASC,EAAYH,CAAM,EAC5CC,CACX,CA2OA,IAAIG,GACJ,SAASC,GAAsBrD,EAAW,CACtCoD,GAAoBpD,CACxB,CACA,SAASsD,IAAwB,CAC7B,GAAI,CAACF,GACD,MAAM,IAAI,MAAM,kDAAkD,EACtE,OAAOA,EACX,CAoBA,SAASG,GAAQhF,EAAI,CACjB+E,GAAuB,EAAC,GAAG,SAAS,KAAK/E,CAAE,CAC/C,CAiBA,SAASiF,GAAUjF,EAAI,CACnB+E,GAAuB,EAAC,GAAG,WAAW,KAAK/E,CAAE,CACjD,CAsCA,SAASkF,GAAWf,EAAKgB,EAAS,CAC9B,UAAqB,EAAG,GAAG,QAAQ,IAAIhB,EAAKgB,CAAO,EAC5CA,CACX,CAOA,SAASC,GAAWjB,EAAK,CACrB,OAAOY,GAAuB,EAAC,GAAG,QAAQ,IAAIZ,CAAG,CACrD,CA+BA,MAAMkB,EAAmB,GAEnBC,GAAoB,GACpBC,GAAmB,GACnBC,GAAkB,GAClBC,GAAmB,QAAQ,UACjC,IAAIC,GAAmB,GACvB,SAASC,IAAkB,CAClBD,KACDA,GAAmB,GACnBD,GAAiB,KAAKG,EAAK,EAEnC,CACA,SAASC,IAAO,CACZ,YACOJ,EACX,CACA,SAASK,GAAoB9F,EAAI,CAC7BuF,GAAiB,KAAKvF,CAAE,CAC5B,CAsBA,MAAM+F,GAAiB,IAAI,IAC3B,IAAIC,GAAW,EACf,SAASJ,IAAQ,CACb,MAAMK,EAAkBpB,GACxB,EAAG,CAGC,KAAOmB,GAAWX,EAAiB,QAAQ,CACvC,MAAM5D,EAAY4D,EAAiBW,IACnCA,KACAlB,GAAsBrD,CAAS,EAC/ByE,GAAOzE,EAAU,EAAE,CACtB,CAID,IAHAqD,GAAsB,IAAI,EAC1BO,EAAiB,OAAS,EAC1BW,GAAW,EACJV,GAAkB,QACrBA,GAAkB,IAAG,IAIzB,QAAShD,EAAI,EAAGA,EAAIiD,GAAiB,OAAQjD,GAAK,EAAG,CACjD,MAAMZ,EAAW6D,GAAiBjD,GAC7ByD,GAAe,IAAIrE,CAAQ,IAE5BqE,GAAe,IAAIrE,CAAQ,EAC3BA,IAEP,CACD6D,GAAiB,OAAS,CAClC,OAAaF,EAAiB,QAC1B,KAAOG,GAAgB,QACnBA,GAAgB,IAAG,IAEvBE,GAAmB,GACnBK,GAAe,MAAK,EACpBjB,GAAsBmB,CAAe,CACzC,CACA,SAASC,GAAOC,EAAI,CAChB,GAAIA,EAAG,WAAa,KAAM,CACtBA,EAAG,OAAM,EACTjG,EAAQiG,EAAG,aAAa,EACxB,MAAMjE,EAAQiE,EAAG,MACjBA,EAAG,MAAQ,CAAC,EAAE,EACdA,EAAG,UAAYA,EAAG,SAAS,EAAEA,EAAG,IAAKjE,CAAK,EAC1CiE,EAAG,aAAa,QAAQL,EAAmB,CAC9C,CACL,CAeA,MAAMM,GAAW,IAAI,IACrB,IAAIC,EACJ,SAASC,GAAe,CACpBD,EAAS,CACL,EAAG,EACH,EAAG,CAAE,EACL,EAAGA,CACX,CACA,CACA,SAASE,GAAe,CACfF,EAAO,GACRnG,EAAQmG,EAAO,CAAC,EAEpBA,EAASA,EAAO,CACpB,CACA,SAASG,EAAcC,EAAOC,EAAO,CAC7BD,GAASA,EAAM,IACfL,GAAS,OAAOK,CAAK,EACrBA,EAAM,EAAEC,CAAK,EAErB,CACA,SAASC,EAAeF,EAAOC,EAAOnD,EAAQ7B,EAAU,CACpD,GAAI+E,GAASA,EAAM,EAAG,CAClB,GAAIL,GAAS,IAAIK,CAAK,EAClB,OACJL,GAAS,IAAIK,CAAK,EAClBJ,EAAO,EAAE,KAAK,IAAM,CAChBD,GAAS,OAAOK,CAAK,EACjB/E,IACI6B,GACAkD,EAAM,EAAE,CAAC,EACb/E,IAEhB,CAAS,EACD+E,EAAM,EAAEC,CAAK,CAChB,MACQhF,GACLA,GAER,CAqTA,MAAMkF,GAAW,OAAO,OAAW,IAC7B,OACA,OAAO,WAAe,IAClB,WACA,OAEV,SAASC,GAAcJ,EAAOK,EAAQ,CAClCL,EAAM,EAAE,CAAC,EACTK,EAAO,OAAOL,EAAM,GAAG,CAC3B,CACA,SAASM,GAAwBN,EAAOK,EAAQ,CAC5CH,EAAeF,EAAO,EAAG,EAAG,IAAM,CAC9BK,EAAO,OAAOL,EAAM,GAAG,CAC/B,CAAK,CACL,CASA,SAASO,GAAkBC,EAAY/E,EAAOgF,EAASC,EAAStF,EAAKuF,EAAMN,EAAQ9H,EAAMqI,EAASC,EAAmBC,EAAMC,EAAa,CACpI,IAAIC,EAAIR,EAAW,OACfS,EAAIN,EAAK,OACT9E,EAAImF,EACR,MAAME,EAAc,GACpB,KAAOrF,KACHqF,EAAYV,EAAW3E,GAAG,KAAOA,EACrC,MAAMsF,EAAa,GACbC,EAAa,IAAI,IACjBC,EAAS,IAAI,IAEnB,IADAxF,EAAIoF,EACGpF,KAAK,CACR,MAAMyF,EAAYP,EAAY3F,EAAKuF,EAAM9E,CAAC,EACpC6B,EAAM+C,EAAQa,CAAS,EAC7B,IAAItB,EAAQK,EAAO,IAAI3C,CAAG,EACrBsC,EAIIU,GACLV,EAAM,EAAEsB,EAAW7F,CAAK,GAJxBuE,EAAQa,EAAkBnD,EAAK4D,CAAS,EACxCtB,EAAM,EAAC,GAKXoB,EAAW,IAAI1D,EAAKyD,EAAWtF,GAAKmE,CAAK,EACrCtC,KAAOwD,GACPG,EAAO,IAAI3D,EAAK,KAAK,IAAI7B,EAAIqF,EAAYxD,EAAI,CAAC,CACrD,CACD,MAAM6D,EAAY,IAAI,IAChBC,EAAW,IAAI,IACrB,SAAS5E,EAAOoD,EAAO,CACnBD,EAAcC,EAAO,CAAC,EACtBA,EAAM,EAAEzH,EAAMuI,CAAI,EAClBT,EAAO,IAAIL,EAAM,IAAKA,CAAK,EAC3Bc,EAAOd,EAAM,MACbiB,GACH,CACD,KAAOD,GAAKC,GAAG,CACX,MAAMQ,EAAYN,EAAWF,EAAI,GAC3BS,EAAYlB,EAAWQ,EAAI,GAC3BW,EAAUF,EAAU,IACpBG,EAAUF,EAAU,IACtBD,IAAcC,GAEdZ,EAAOW,EAAU,MACjBT,IACAC,KAEMG,EAAW,IAAIQ,CAAO,EAKvB,CAACvB,EAAO,IAAIsB,CAAO,GAAKJ,EAAU,IAAII,CAAO,EAClD/E,EAAO6E,CAAS,EAEXD,EAAS,IAAII,CAAO,EACzBZ,IAEKK,EAAO,IAAIM,CAAO,EAAIN,EAAO,IAAIO,CAAO,GAC7CJ,EAAS,IAAIG,CAAO,EACpB/E,EAAO6E,CAAS,IAGhBF,EAAU,IAAIK,CAAO,EACrBZ,MAfAJ,EAAQc,EAAWrB,CAAM,EACzBW,IAgBP,CACD,KAAOA,KAAK,CACR,MAAMU,EAAYlB,EAAWQ,GACxBI,EAAW,IAAIM,EAAU,GAAG,GAC7Bd,EAAQc,EAAWrB,CAAM,CAChC,CACD,KAAOY,GACHrE,EAAOuE,EAAWF,EAAI,EAAE,EAC5B,OAAOE,CACX,CACA,SAASU,GAAmBzG,EAAKuF,EAAMI,EAAaN,EAAS,CACzD,MAAMqB,EAAO,IAAI,IACjB,QAASjG,EAAI,EAAGA,EAAI8E,EAAK,OAAQ9E,IAAK,CAClC,MAAM6B,EAAM+C,EAAQM,EAAY3F,EAAKuF,EAAM9E,CAAC,CAAC,EAC7C,GAAIiG,EAAK,IAAIpE,CAAG,EACZ,MAAM,IAAI,MAAM,4CAA4C,EAEhEoE,EAAK,IAAIpE,CAAG,CACf,CACL,CAEA,SAASqE,GAAkBC,EAAQC,EAAS,CACxC,MAAMxC,EAAS,GACTyC,EAAc,GACdC,EAAgB,CAAE,QAAS,GACjC,IAAItG,EAAImG,EAAO,OACf,KAAOnG,KAAK,CACR,MAAMmF,EAAIgB,EAAOnG,GACXoF,EAAIgB,EAAQpG,GAClB,GAAIoF,EAAG,CACH,UAAWvD,KAAOsD,EACRtD,KAAOuD,IACTiB,EAAYxE,GAAO,GAE3B,UAAWA,KAAOuD,EACTkB,EAAczE,KACf+B,EAAO/B,GAAOuD,EAAEvD,GAChByE,EAAczE,GAAO,GAG7BsE,EAAOnG,GAAKoF,CACf,KAEG,WAAWvD,KAAOsD,EACdmB,EAAczE,GAAO,CAGhC,CACD,UAAWA,KAAOwE,EACRxE,KAAO+B,IACTA,EAAO/B,GAAO,QAEtB,OAAO+B,CACX,CACA,SAAS2C,GAAkBC,EAAc,CACrC,OAAO,OAAOA,GAAiB,UAAYA,IAAiB,KAAOA,EAAe,EACtF,CA2NA,SAASC,EAAiBtC,EAAO,CAC7BA,GAASA,EAAM,GACnB,CAIA,SAASuC,EAAgBvH,EAAW2B,EAAQE,EAAQ2F,EAAe,CAC/D,KAAM,CAAE,WAAU,gBAAiBxH,EAAU,GAC7CyH,GAAYA,EAAS,EAAE9F,EAAQE,CAAM,EAChC2F,GAEDnD,GAAoB,IAAM,CACtB,MAAMqD,EAAiB1H,EAAU,GAAG,SAAS,IAAI1B,EAAG,EAAE,OAAOK,EAAW,EAIpEqB,EAAU,GAAG,WACbA,EAAU,GAAG,WAAW,KAAK,GAAG0H,CAAc,EAK9CjJ,EAAQiJ,CAAc,EAE1B1H,EAAU,GAAG,SAAW,EACpC,CAAS,EAEL2H,EAAa,QAAQtD,EAAmB,CAC5C,CACA,SAASuD,EAAkB5H,EAAWiC,EAAW,CAC7C,MAAMyC,EAAK1E,EAAU,GACjB0E,EAAG,WAAa,OAChBjG,EAAQiG,EAAG,UAAU,EACrBA,EAAG,UAAYA,EAAG,SAAS,EAAEzC,CAAS,EAGtCyC,EAAG,WAAaA,EAAG,SAAW,KAC9BA,EAAG,IAAM,GAEjB,CACA,SAASmD,GAAW7H,EAAWa,EAAG,CAC1Bb,EAAU,GAAG,MAAM,KAAO,KAC1B4D,EAAiB,KAAK5D,CAAS,EAC/BkE,KACAlE,EAAU,GAAG,MAAM,KAAK,CAAC,GAE7BA,EAAU,GAAG,MAAOa,EAAI,GAAM,IAAO,GAAMA,EAAI,EACnD,CACA,SAASiH,GAAK9H,EAAW+H,EAASC,EAAUC,EAAiBC,EAAWC,EAAOC,EAAe3H,EAAQ,CAAC,EAAE,EAAG,CACxG,MAAM4H,EAAmBjF,GACzBC,GAAsBrD,CAAS,EAC/B,MAAM0E,EAAK1E,EAAU,GAAK,CACtB,SAAU,KACV,IAAK,CAAE,EAEP,QACA,OAAQrC,EACR,YACA,MAAOa,GAAc,EAErB,SAAU,CAAE,EACZ,WAAY,CAAE,EACd,cAAe,CAAE,EACjB,cAAe,CAAE,EACjB,aAAc,CAAE,EAChB,QAAS,IAAI,IAAIuJ,EAAQ,UAAYM,EAAmBA,EAAiB,GAAG,QAAU,GAAG,EAEzF,UAAW7J,GAAc,EACzB,QACA,WAAY,GACZ,KAAMuJ,EAAQ,QAAUM,EAAiB,GAAG,IACpD,EACID,GAAiBA,EAAc1D,EAAG,IAAI,EACtC,IAAI4D,EAAQ,GAkBZ,GAjBA5D,EAAG,IAAMsD,EACHA,EAAShI,EAAW+H,EAAQ,OAAS,CAAE,EAAE,CAAClH,EAAGU,KAAQgH,IAAS,CAC5D,MAAM1I,EAAQ0I,EAAK,OAASA,EAAK,GAAKhH,EACtC,OAAImD,EAAG,KAAOwD,EAAUxD,EAAG,IAAI7D,GAAI6D,EAAG,IAAI7D,GAAKhB,CAAK,IAC5C,CAAC6E,EAAG,YAAcA,EAAG,MAAM7D,IAC3B6D,EAAG,MAAM7D,GAAGhB,CAAK,EACjByI,GACAT,GAAW7H,EAAWa,CAAC,GAExBU,CACnB,CAAS,EACC,GACNmD,EAAG,OAAM,EACT4D,EAAQ,GACR7J,EAAQiG,EAAG,aAAa,EAExBA,EAAG,SAAWuD,EAAkBA,EAAgBvD,EAAG,GAAG,EAAI,GACtDqD,EAAQ,OAAQ,CAChB,GAAIA,EAAQ,QAAS,CAEjB,MAAMS,EAAQhG,GAASuF,EAAQ,MAAM,EAErCrD,EAAG,UAAYA,EAAG,SAAS,EAAE8D,CAAK,EAClCA,EAAM,QAAQ1G,EAAM,CACvB,MAGG4C,EAAG,UAAYA,EAAG,SAAS,EAAC,EAE5BqD,EAAQ,OACRhD,EAAc/E,EAAU,GAAG,QAAQ,EACvCuH,EAAgBvH,EAAW+H,EAAQ,OAAQA,EAAQ,OAAQA,EAAQ,aAAa,EAEhF5D,IACH,CACDd,GAAsBgF,CAAgB,CAC1C,CAoDA,MAAMI,EAAgB,CAClB,UAAW,CACPb,EAAkB,KAAM,CAAC,EACzB,KAAK,SAAWjK,CACnB,CACD,IAAIoF,EAAM9C,EAAU,CAChB,GAAI,CAACtB,GAAYsB,CAAQ,EACrB,OAAOtC,EAEX,MAAM+B,EAAa,KAAK,GAAG,UAAUqD,KAAU,KAAK,GAAG,UAAUA,GAAQ,IACzE,SAAU,KAAK9C,CAAQ,EAChB,IAAM,CACT,MAAMyI,EAAQhJ,EAAU,QAAQO,CAAQ,EACpCyI,IAAU,IACVhJ,EAAU,OAAOgJ,EAAO,CAAC,CACzC,CACK,CACD,KAAKC,EAAS,CACN,KAAK,OAAS,CAACvJ,GAASuJ,CAAO,IAC/B,KAAK,GAAG,WAAa,GACrB,KAAK,MAAMA,CAAO,EAClB,KAAK,GAAG,WAAa,GAE5B,CACL,CAEA,SAASC,EAAa7F,EAAMC,EAAQ,CAChC,SAAS,cAAcF,GAAaC,EAAM,OAAO,OAAO,CAAE,QAAS,QAAU,EAAEC,CAAM,EAAG,CAAE,QAAS,EAAI,CAAE,CAAC,CAC9G,CACA,SAAS6F,GAAWlH,EAAQpE,EAAM,CAC9BqL,EAAa,kBAAmB,CAAE,SAAQ,MAAM,GAChDlH,GAAOC,EAAQpE,CAAI,CACvB,CAKA,SAASuL,EAAWnH,EAAQpE,EAAMsE,EAAQ,CACtC+G,EAAa,kBAAmB,CAAE,SAAQ,OAAM,QAAQ,GACxDhH,GAAOD,EAAQpE,EAAMsE,CAAM,CAC/B,CAKA,SAASkH,EAAWxL,EAAM,CACtBqL,EAAa,kBAAmB,CAAE,MAAI,CAAE,EACxC9G,GAAOvE,CAAI,CACf,CA6BA,SAASyL,GAASzL,EAAMgF,EAAW1C,EAAO,CACtCyC,GAAK/E,EAAMgF,EAAW1C,CAAK,EACvBA,GAAS,KACT+I,EAAa,2BAA4B,CAAE,OAAM,WAAW,GAE5DA,EAAa,wBAAyB,CAAE,OAAM,YAAW,OAAO,EACxE,CAgBA,SAASK,GAAuBC,EAAK,CACjC,GAAI,OAAOA,GAAQ,UAAY,EAAEA,GAAO,OAAOA,GAAQ,UAAY,WAAYA,GAAM,CACjF,IAAIC,EAAM,iDACV,MAAI,OAAO,QAAW,YAAcD,GAAO,OAAO,YAAYA,IAC1DC,GAAO,iEAEL,IAAI,MAAMA,CAAG,CACtB,CACL,CACA,SAASC,GAAe5J,EAAMuB,EAAM+F,EAAM,CACtC,UAAWuC,KAAY,OAAO,KAAKtI,CAAI,EAC9B,CAAC+F,EAAK,QAAQuC,CAAQ,GACvB,QAAQ,KAAK,IAAI7J,mCAAsC6J,KAAY,CAG/E,CAYA,SAASC,GAA+BtJ,EAAWmI,EAAO,CACtD,MAAMoB,EAAgB,sEACtB,GAAI,CACA,MAAMvB,EAAW,IAAIhI,EAAUmI,CAAK,EACpC,GAAI,CAACH,EAAS,IAAM,CAACA,EAAS,MAAQ,CAACA,EAAS,KAAO,CAACA,EAAS,SAC7D,MAAM,IAAI,MAAMuB,CAAa,EAEjC,OAAOvB,CACV,OACMwB,EAAP,CACI,KAAM,CAAE,SAAS,EAAGA,EACpB,MAAI,OAAOC,GAAY,UAAYA,EAAQ,QAAQ,sBAAsB,IAAM,GACrE,IAAI,MAAMF,CAAa,EAGvBC,CAEb,CACL,CAIA,MAAME,WAA2BjB,EAAgB,CAC7C,YAAYV,EAAS,CACjB,GAAI,CAACA,GAAY,CAACA,EAAQ,QAAU,CAACA,EAAQ,SACzC,MAAM,IAAI,MAAM,+BAA+B,EAEnD,OACH,CACD,UAAW,CACP,MAAM,SAAQ,EACd,KAAK,SAAW,IAAM,CAClB,QAAQ,KAAK,iCAAiC,CAC1D,CACK,CACD,gBAAiB,CAAG,CACpB,eAAgB,CAAG,CACvB,4mBC5qEA,SAAS4B,EAAqBpL,EAAI,CAM9B,MAAMqL,EAAQ,eAAuBC,EAAS,CAC1C,OAAO,MAAMC,GAAevL,EAAI,CAC5B,KAAMsL,EAAQ,KACd,MAAO,CAAE,YAAaA,CAAS,EAC/B,MAAO,CAAE,CACrB,CAAS,CACJ,EAMD,SAAM,KAAO,SAAqBA,EAAS,CACvC,OAAOE,GAAmBxL,EAAI,CAC1B,KAAMsL,EAAQ,KACd,MAAO,CAAE,YAAaA,CAAS,EAC/B,MAAO,CAAE,CACrB,CAAS,CACJ,EAEMD,CACX,CAOA,eAAeE,GAAevL,EAAIsL,EAAS,CACvC,MAAMG,EAAQ,MAAMzL,EAAGsL,CAAO,EAC9B,GAAIG,IAAU,GAAO,MAAO,GAC5B,MAAM9L,EAAO8L,GAASH,EAAQ,KAE9B,GAAI3L,EAAK,SAAU,CACf,MAAMsE,EAAW,MAAM,QAAQ,IAAItE,EAAK,SAAS,IAAI,MAAM8L,GAASF,GAAevL,EAAI,CACnF,MAAOsL,EAAQ,MACf,MAAOI,GAAMJ,EAAQ,OAAS,EAAE,EAChC,OAAQA,EAAQ,KAChB,KAAM,MAAMG,CACf,EAAC,CAAC,EACH9L,EAAK,SAAWsE,EAAS,OAAO,OAAO,CAC1C,CAED,OAAOtE,CACX,CAOA,SAAS6L,GAAmBxL,EAAIsL,EAAS,CACrC,MAAMG,EAAQzL,EAAGsL,CAAO,EACxB,GAAIG,IAAU,GAAO,MAAO,GAE5B,MAAM9L,EAAO8L,GAASH,EAAQ,KAE9B,GAAI3L,EAAK,SAAU,CACf,MAAMsE,EAAWtE,EAAK,SAAS,IAAI8L,GAASD,GAAmBxL,EAAI,CAC/D,MAAOsL,EAAQ,MACf,MAAOI,GAAMJ,EAAQ,OAAS,EAAE,EAChC,OAAQA,EAAQ,KAChB,KAAMG,CAClB,CAAS,CAAC,EACF9L,EAAK,SAAWsE,EAAS,OAAO,OAAO,CAC1C,CAED,OAAOtE,CACX,CASA,SAAS+L,GAAM5K,EAAK,CAAE,OAAO,KAAK,MAAM,KAAK,UAAUA,CAAG,CAAC,CAAC,CC3G5D,MAAe6K,GACX,aAAc,CACV,MAAOC,GAAUC,GAAY,IAAI,gBAAgBD,CAAM,CAAC,EACxD,UAAWE,GAAU,IAAO,IAAI,gBAAgBA,CAAM,EAAG,SAAU,CACtE,EACD,aAAc,CACV,MAAOC,GAAKA,EACZ,OAAQA,GAAKA,CAChB,EACD,QAAS,EACb,EAGA,SAASF,GAAYG,EAAU,CAC3B,MAAO,CAAC,GAAGA,CAAQ,EAAE,OAAO,CAAClL,EAAK,CAACqD,EAAK8H,CAAG,KACvCnL,EAAIqD,GAAO8H,EACJnL,GACR,EAAE,CACT,CChBA,MAAMoL,GAAc,OAAO,cAAc,EAElC,SAASC,GAAazM,EAAS0M,EAAa,CACjD,GAAI,UAAU,UAAU,SAAS,OAAO,EAAG,MAAO,GAC9CA,GAAaC,GAAqB3M,CAAO,EAC7C4M,GAAY,CACd,CAEO,SAASA,IAAa,CAC3B,GAAI,UAAU,UAAU,SAAS,OAAO,EAAG,MAAO,GAClD,KAAM,CAAE,QAAS,OAAO,SACxB,GAAIC,EAAM,CACR,MAAMC,EAAK,SAAS,eAAeD,EAAK,UAAU,CAAC,CAAC,EAChDC,GAAIA,EAAG,eAAgB,CAC5B,CACH,CAEO,SAASH,GAAqB3M,EAAS,CAE1CA,GACAA,EAAQ,UACRA,EAAQ,QAAQ,UAAY,eAC5BA,EAAQ,QAAQ,oBAAsB,SAEtCA,EAAQ,MAAM,mBAAqB,OACnCA,EAAQ,SAAS,CAAE,IAAK,EAAG,SAAU,OAAQ,EAC7CA,EAAQ,MAAM,mBAAqB,GACnC2M,GAAqB3M,EAAQ,aAAa,EAE9C,CAEO,MAAM+M,GAAc,CAACC,EAAKC,IAAc,CAC7C,MAAMC,EAASD,EAAY,GAAK,MAChC,SAAMD,EAAI,QAAQ,gBAAiB,OAAO,EAC1CA,EAAMA,EAAI,QAAQ,WAAY,WAAW,EACzCA,EAAMA,EAAI,QAAQR,GAAa,SAAS,EAAIU,EAC5CF,EAAM,IAAIA,IACHA,CACT,EAEaG,GAAkBC,GAAU,CACvC,MAAMC,EAAa,CAAE,EACrB,IAAIC,EACJ,KAAQA,EAAUd,GAAY,KAAKY,CAAM,GAAIC,EAAW,KAAKC,EAAQ,EAAE,EACvE,OAAOD,CACT,EAEaE,GAAa,CAAC,CAAE,UACpBC,EACJ,MAAM,GAAG,EACT,OAAO,OAAO,EACd,IAAIR,GAAQA,IAAQ,YAAc,IAAMA,EAAI,WAAW,GAAG,EAAI,IAAM,GAAI,EACxE,KAAK,EAAE,EAIL,SAASS,GAA0BtL,EAAKgE,EAAM,CACnDsH,GAA0B,SAAWA,GAA0B,UAAY,CAAE,IAAK,QAAQ,IAAK,KAAM,QAAQ,IAAM,EACnH,KAAM,CAAE,UAAQ,EAAKA,GAEflM,EAAOY,EAAI,cAAc,KAC5B,QAAQ,gBAAiB,IAAI,EAC7B,QAAQ,UAAWA,EAAI,UAAU,UAAU,MAAM,GAAG,EAAE,KAAK,EAC3D,QAAQ,KAAM,GAAK,EAAE,YAAW,CAAE,EAClC,QAAQ,SAAU,UAAU,EAEzBuL,EAAU,CACd,IAAInM,4CACJ,IAAIA,4CACJ,IAAIA,+CACL,EACD,UAAWoM,IAAO,CAAC,MAAO,MAAM,EAC9B,QAAQA,GAAO,IAAIC,IAAS,CACrBF,EAAQ,SAASE,EAAK,EAAE,GAC3BC,EAASF,GAAK,GAAGC,CAAI,CACxB,EACDzH,EAAI,EAAG,KAAK,IAAM,CAEhB,QAAQwH,GAAOE,EAASF,EAC9B,CAAK,CAEL,CAEO,SAASG,IAAkB,CAChC,IAAIC,EAAgB,OAAO,SAAS,SAAW,OAAO,SAAS,OAAS,OAAO,SAAS,KACxF,KAAM,CAAE,MAAK,WAAYC,GAAgBD,CAAa,EAGtD,MAAO,CAAE,GAFSE,GAAS/M,CAAG,EAEP,SAAS,CAClC,CAOA,SAAS8M,GAAgBD,EAAe,CACtC,KAAM,CAAC7M,EAAKgN,CAAQ,EAAIH,EAAc,MAAM,6BAA6B,EAEnEjE,EAAU,KAAK,MAAM,mBAAmBoE,GAAY,EAAE,GAAK,IAAI,EAErE,cAAO,QAAU,OAAO,SAAW,CAAE,EACrC,OAAO,QAAQ,WAAapE,EAAQ,SAE7B,CAAE,MAAK,SAAS,CACzB,CAMO,SAASmE,GAAS/M,EAAK,CACxBiN,EAAO,UACTjN,EAAMA,EAAI,QAAQ,UAAW,IAAI,GACnC,MAAMkN,EAASlN,EAAI,WAAW,GAAG,EAAI,OAAO,SAAS,OAAS,OACxDmN,EAAO,IAAI,IAAInN,EAAKkN,CAAM,EAC1BE,EAAWD,EAAK,SAAWA,EAAK,OAASA,EAAK,KACpD,MAAO,CAAE,IAAKA,EAAM,UAAU,CAChC,CAUO,SAASE,GAAWf,EAAMpB,EAAQoC,EAAiB,CACxD,MAAM3B,EAAOsB,EAAO,QAAU,IAAM,GACpC,IAAIjN,EACJ,SAAMuN,GAAYjB,EAAMpB,EAAQoC,CAAe,EAC/CtN,EAAMiN,EAAO,aAAa,MAAMjN,CAAG,EACnCA,EAAM2L,EAAO3L,EACNA,CACT,CASO,SAASuN,GAAYjB,EAAMpB,EAAQoC,EAAiB,CACzD,MAAME,EAAY,OAAO,OAAO,GAAIF,EAAiBpC,CAAM,EACrDuC,EAAcC,GAAepB,EAAMpB,CAAM,EAE/C,SAAW,CAAC3H,EAAK7C,CAAK,IAAK,OAAO,QAAQ8M,CAAS,EACjDlB,EAAOA,EAAK,QAAQ,IAAI/I,IAAO7C,CAAK,EAEtC,MAAO,GAAG4L,IAAOmB,GACnB,CAQA,SAASC,GAAepB,EAAMpB,EAAQ,CACpC,GAAI,CAAC+B,EAAO,aAAc,MAAO,GACjC,MAAMU,EAAc1B,GAAgBK,CAAI,EAClCsB,EAAc,CAAE,EACtB,OAAI1C,GAAQ,OAAO,QAAQA,CAAM,EAAE,QAAQ,CAAC,CAAC3H,EAAK7C,CAAK,IAAM,CACtDiN,EAAY,SAASpK,CAAG,IAC3BqK,EAAYrK,GAAO7C,EACzB,CAAG,EACMuM,EAAO,aAAa,UAAUW,CAAW,EAAE,QAAQ,MAAO,EAAE,CACrE,CCxKO,MAAMC,GAAWrD,EAAqB,CAAC,CAAE,UAAW,EACnDzL,EAAK,QAAUA,EAAK,cACpBA,EAAK,MAAQ8M,GAAY9M,EAAK,KAAMA,EAAK,UAAU,EAC3D,CAAC,EACY+O,GAAetD,EAAqB,CAAC,CAAE,UAAW,CAC3DzL,EAAK,UAAYkN,GAAgBlN,EAAK,IAAI,CAC9C,CAAC,EAEYgP,GAAevD,EAAqB,CAAC,CAAE,UAAW,CACvDzL,EAAK,YAAcA,EAAK,QACxBA,EAAK,UAAYA,EAAK,KAAK,QAAQ,WAAY,EAAE,EAChDA,EAAK,UAAYA,EAAK,IAC/B,CAAC,EACYiP,GAAUxD,EAAqB,CAAC,CAAE,UAAW,CACtDzL,EAAK,QAAUsN,GAAWtN,CAAI,CAClC,CAAC,EAIYkP,GAAkBzD,EAAqB,CAAC,CAAE,UAAW,CAC9D,MAAMpM,EAAOW,EACPmP,EAAenP,EAAK,MAAQA,EAAK,KAAK,UAAY,CAAE,EACtDmP,EAAa,SACb9P,EAAK,SAAWA,EAAK,UAAY,CAAE,EACnCA,EAAK,SAAS,KAAK,GAAG8P,EAAa,IAAIC,IAAS,CAAE,OAAQ,GAAM,GAAGA,EAAM,MAAI,EAAG,CAAC,EAEzF,CAAC,EAEYC,GAAiB5D,EAAqBE,GAAW,CAC1D,KAAM,CAAE,MAAI,EAAKA,EACX,CAAE,aAAY,MAAI,EAAK3L,EACvBsP,EAAYtP,EAAK,KAAK,MAAM,GAAG,EAAE,IAAG,EAAG,WAAW,GAAG,EACrDuP,EAAUvP,EAAK,KAAK,SAAS,QAAQ,EACrCwP,EAAYJ,EAAK,OAASA,EAAK,QAAU,EACzCK,EAAWL,EAAK,QAAU,GAEhCpP,EAAK,YAAcwP,GAAc,CAACE,GAAc,CAACJ,GAAa,CAACC,GAAW,CAACE,EAC3EzP,EAAK,eAAiB,CAACA,EAAK,WAChC,CAAC,EAEY2P,GAAkBlE,EAAqB,CAAC,CAAE,OAAM,QAAM,IAAO,CACtE,OAAO,eAAezL,EAAM,SAAU,CAAE,IAAK,IAAM4P,EAAQ,EAC3D,OAAO,eAAe5P,EAAM,cAAe,CAAE,IAAK,IAAM6P,GAAY7P,EAAM,CAAC,EAAG,EAC9E,OAAO,eAAeA,EAAM,cAAe,CAAE,IAAK,IAAM6P,GAAY7P,EAAM,EAAE,EAAG,EAC/E,OAAO,eAAeA,EAAM,UAAW,CAAE,IAAK,IAAM8P,GAAYF,CAAM,EAAG,CAC7E,CAAC,EAED,SAASE,GAAYzQ,EAAM0Q,EAAU,GAAI,CACrC,OAAI1Q,IACA0Q,EAAQ,QAAQ1Q,CAAI,EACpByQ,GAAYzQ,EAAK,OAAQ0Q,CAAO,GAE7BA,CACX,CAOA,SAASF,GAAY7P,EAAMgQ,EAAW,CAClC,GAAI,CAAChQ,EAAK,KAAM,CACZ,MAAMiQ,EAAWjQ,EAAK,OAAO,SAAS,OAAOkQ,GAAKA,EAAE,WAAW,EACzD1F,EAAQyF,EAAS,QAAQjQ,CAAI,EACnC,OAAOiQ,EAASzF,EAAQwF,EAC3B,CACL,CAEO,MAAMG,GAAc1E,EAAqB,CAAC,CAAE,OAAM,QAAM,IAAO,CAC9DzL,EAAK,SAAS,OAAO,eAAe4P,EAAQ,QAAS,CAAE,IAAK,IAAM5P,EAAM,CAChF,CAAC,EAEYoQ,GAAe3E,EAAqB,CAAC,CAAE,OAAM,OAAK,IAAO,CAElE,OAAO,eAAezL,EAAM,UAAW,CAAE,IAAK,IAAMqQ,EAAWrQ,CAAI,EAAG,EAOtE,SAASqQ,EAAWrQ,EAAM,CAEtB,GAAI,CAACA,EAAK,UAAYA,EAAK,KAAK,MAAO,MAAO,CAAE,EAEhD,KAAM,CAAE,QAAM,EAAKA,EACbsQ,EAASV,GAAUA,EAAO,WAAaA,EACvCW,EAAUD,IAAWA,EAAO,SAAWA,EAAO,KAAK,OACnDE,EAAWZ,GAAU,CAACW,GAAWF,EAAWT,CAAM,GAAM,CAAE,EAChE,OAAIU,GAAQE,EAAQ,KAAKF,CAAM,EACxBE,CACV,CACL,CAAC,EAGYC,GAAiBC,GAAe,CACzCjF,EAAqBE,GAAW,EACxBA,EAAQ,KAAK,QAAUA,EAAQ,KAAK,aACpCA,EAAQ,MAAM,YAAY,OAAO,KAAKA,EAAQ,IAAI,CAC9D,CAAK,EAAE,KAAK+E,CAAW,EACnBA,EAAY,OAAO,KAAK,CAACR,EAAGS,IAAOT,EAAE,SAAWS,EAAE,QAAU,GAAK,CAAE,CACvE,EAEaC,GAAenF,EAAqB,CAAC,CAAE,UAAW,CAC3D,MAAMoF,EAAY7Q,EAAK,KACjB8Q,EACA9Q,EAAK,SACDA,EAAK,OAAS+Q,EAAUC,EACxBhR,EAAK,QACDiR,EACAjR,EAAK,SACDkR,EACAlR,EAAK,WACDmR,EACAC,EACtB,OAAO,eAAepR,EAAM6Q,EAAU,SAAS,EAE/C,SAASK,GAAS,CAAG,CACrB,SAASF,GAAM,CAAG,CAClB,SAASG,GAAW,CAAG,CACvB,SAASC,GAAO,CAAG,CACnB,SAASL,GAAU,CAAG,CACtB,SAASE,GAAQ,CAAG,CACpB,SAASH,GAAO,CAAG,CACvB,CAAC,gRC/HYO,GAAc,CACvB,MAAS,GACT,IAAO,SACP,SAAY,GACZ,QAAW,GACX,QAAW,GACX,WAAc,GACd,OAAU,GACV,QAAW,CAAE,EACb,KAAQ,CACJ,UAAa,GACb,QAAW,GACX,UAAa,EAChB,EACD,GAAM,YACV,EAsBO,SAASC,GAAgBjS,EAAM,CAClC,cAAO,QAAQgS,EAAW,EAAE,QAAQ,CAAC,CAAC7M,EAAK7C,CAAK,IAAM,CAC9C,OAAOtC,EAAKmF,GAAS,MACrBnF,EAAKmF,GAAO7C,EACxB,CAAK,EAEEtC,EAAK,WACJA,EAAK,SAAWA,EAAK,SAAS,IAAIiS,EAAe,GAE9CjS,CACX,CC9CO,MAAMkS,GAAY9F,EAAqB,CAAC,CAAE,UAAW,CACxDzL,EAAK,IAAM,IAAIwR,GAAUxR,CAAI,CACjC,CAAC,EAED,MAAMwR,EAAU,CACZ,YAAYxR,EAAM,CACd,KAAK,OAASA,EACd,OAAO,eAAe,KAAM,SAAU,CAAE,WAAY,GAAO,EAC3D,KAAK,OAAS,CAAC,CAACA,EAAK,OACrB,KAAK,KAAOA,EAAK,KACjB,KAAK,MAAQyR,GAAYzR,CAAI,EAC7B,KAAK,KAAOA,EAAK,IACpB,CAED,IAAI,QAAS,CAAE,MAAO,CAAC,KAAK,OAAO,MAAQ,KAAK,OAAO,OAAO,GAAK,CACnE,IAAI,UAAW,CACX,OAAQ,KAAK,OAAO,UAAY,KAAK,OAAO,UAAY,KAAK,OAAO,OAAO,UAAY,CAAE,GACpF,OAAOkQ,GAAK,CAACA,EAAE,cAAc,EAC7B,KAAK,CAACtP,EAAGC,IACFD,EAAE,QAAUC,EAAE,OAAe,GACjCD,GAAKA,EAAE,KAAK,OAASA,EAAE,KAAK,OAASA,EAAE,MAAM,SAAU,EACvDC,GAAKA,EAAE,KAAK,OAASA,EAAE,KAAK,OAASA,EAAE,MAAM,SAAU,EAChDD,EAAE,cAAeC,EAAI,OAAW,CAAE,QAAS,GAAM,YAAa,OAAQ,EAChF,EACA,IAAI,CAAC,CAAE,KAAK,IAAK6Q,CAAG,CAC5B,CACD,IAAI,MAAO,CAAE,OAAOC,GAAU,KAAM,CAAE,CAAG,CACzC,IAAI,MAAO,CAAE,OAAOA,GAAU,KAAM,EAAE,CAAG,CACzC,MAAM,SAAU,CACZ,MAAMC,EAAe,CACjB,GAAG,KAAK,OAAO,QACf,KAAK,OACL,KAAK,OAAS,KAAK,MAAM,MAC5B,EACI,OAAO,OAAO,EACd,IAAI5R,GAAQA,EAAK,WAAW,EACjC,MAAM,QAAQ,IAAI4R,CAAY,CACjC,CACD,IAAI,WAAY,CACZ,OAAO,KAAK,OAAO,UACf,KAAK,OAAO,UAAW,EACrB,KAAK,OAAO,MACV,KAAK,OAAO,MAAM,UAAW,EAC3B,EACb,CACD,IAAI,oBAAqB,CACrB,OAAO,IAAI,QAAQC,GACf,QAAQ,IAAI,CACR,KAAK,UACL,KAAK,OAAS,KAAK,MAAM,SACzC,CAAa,EACI,KAAKC,GAAOD,EAAQC,CAAG,CAAC,CAChC,CACJ,CACD,IAAI,OAAQ,CACR,MAAMC,EAAQ,KAAK,OAAO,UACtB,KAAK,OAAO,SAAS,KAAKA,GAASA,EAAM,OAAO,EACpD,OAAOA,GAASA,EAAM,GACzB,CACL,CAEA,SAASJ,GAAUtS,EAAM2Q,EAAW,CAChC,GAAI,CAAC3Q,EAAK,OAAO,KAAM,CAEnB,MAAMmL,EADWnL,EAAK,OAAO,SACN,QAAQA,CAAI,EACnC,OAAOA,EAAK,OAAO,SAASmL,EAAQwF,EACvC,CACL,CAGA,SAASyB,GAAYzR,EAAM,CACvB,OAAI,OAAOA,EAAK,KAAK,MAAU,IAAoBA,EAAK,KAAK,OAChDA,EAAK,WAAaA,EAAK,MAC/B,MAAM,GAAG,EACT,IAAK,EACL,QAAQ,KAAM,GAAG,CAC1B,CCvEA,MAAMgS,GAAU,CACd,GAAGC,GACH,gBAAiB,CAAC,CAAE,UAAWX,GAAgBY,CAAI,EACnD,YACF,EAEO,SAASC,GAAgBD,EAAM,CACpC,MAAME,EAAQ,CAEZ,kBAEA,eACA,WACA,eACA,UACA,eAEA,eACA,kBACA,kBACA,iBACA,cACA,YAEA,gBACD,EAEKzG,EAAU,CAAE,OAAM,OAAQ,EAAI,EACpC,QAASrK,KAAQ8Q,GAEJJ,GAAQ1Q,GAAM,MAAQ0Q,GAAQ1Q,IACtCqK,CAAO,EAEZ,OAAOA,CACT,CCrBO,MAAM0G,GAAQ,CACnB,KAAQ,GACR,SAAY,CACV,CACE,WAAc,GACd,KAAQ,aACR,UAAa,IAAKC,MAAC,OAAO,2BAA+B,IAAE,KAAKC,GAAKA,EAAE,OAAO,CAC/E,EACD,CACE,MAAS,GACT,SAAY,CACV,CACE,QAAW,GACX,OAAU,GACV,KAAQ,CACN,WAAc,0BACd,UAAa,GACb,QAAW,GACX,UAAa,EACd,EACD,KAAQ,cACR,GAAM,cACN,UAAa,IAAKD,MAAC,OAAO,sCAA2B,wFAAE,KAAKC,GAAKA,EAAE,WAAW,CAC/E,CACF,EACD,SAAY,GACZ,QAAW,CACT,OAAU,EACX,EACD,KAAQ,CACN,OAAU,GACV,WAAc,0BACd,UAAa,GACb,QAAW,GACX,UAAa,EACd,EACD,KAAQ,QACR,GAAM,gBACN,UAAa,IAAMD,aAAO,8HAA6B,KAAKC,GAAKA,EAAE,aAAa,CACjF,EACD,CACE,QAAW,GACX,OAAU,GACV,KAAQ,SACR,GAAM,SACN,UAAa,IAAMD,aAAO,uBAA4B,IAAC,KAAKC,GAAKA,EAAE,OAAO,CAC3E,EACD,CACE,MAAS,GACT,SAAY,CACV,CACE,QAAW,GACX,OAAU,GACV,KAAQ,CACN,WAAc,2BACd,UAAa,GACb,QAAW,GACX,UAAa,EACd,EACD,KAAQ,eACR,GAAM,eACN,UAAa,IAAMD,aAAO,uCAA4B,0FAAE,KAAKC,GAAKA,EAAE,YAAY,CACjF,CACF,EACD,SAAY,GACZ,QAAW,CACT,OAAU,EACX,EACD,KAAQ,CACN,OAAU,GACV,WAAc,2BACd,UAAa,GACb,QAAW,GACX,UAAa,EACd,EACD,KAAQ,SACR,GAAM,iBACN,UAAa,IAAMD,aAAO,uCAA4B,0FAAE,KAAKC,GAAKA,EAAE,cAAc,CACnF,EACD,CACE,MAAS,GACT,SAAY,CACV,CACE,QAAW,GACX,OAAU,GACV,KAAQ,CACN,WAAc,8BACd,UAAa,GACb,QAAW,GACX,UAAa,EACd,EACD,KAAQ,kBACR,GAAM,kBACN,UAAa,IAAKD,MAAC,OAAO,0CAAgC,gGAAC,KAAKC,GAAKA,EAAE,eAAe,CACvF,CACF,EACD,SAAY,GACZ,QAAW,CACT,OAAU,EACX,EACD,KAAQ,CACN,OAAU,GACV,WAAc,8BACd,UAAa,GACb,QAAW,GACX,UAAa,EACd,EACD,KAAQ,YACR,GAAM,oBACN,UAAa,IAAMD,aAAO,0CAAgC,gGAAC,KAAKC,GAAKA,EAAE,iBAAiB,CACzF,EACD,CACE,MAAS,GACT,SAAY,CACV,CACE,QAAW,GACX,OAAU,GACV,KAAQ,CACN,WAAc,2BACd,UAAa,GACb,QAAW,GACX,UAAa,EACd,EACD,KAAQ,eACR,GAAM,eACN,UAAa,IAAMD,aAAO,uCAA4B,0FAAE,KAAKC,GAAKA,EAAE,YAAY,CACjF,CACF,EACD,SAAY,GACZ,QAAW,CACT,OAAU,EACX,EACD,KAAQ,CACN,OAAU,GACV,WAAc,2BACd,UAAa,GACb,QAAW,GACX,UAAa,EACd,EACD,KAAQ,SACR,GAAM,iBACN,UAAa,IAAMD,aAAO,uCAA4B,0FAAE,KAAKC,GAAKA,EAAE,cAAc,CACnF,CACF,EACD,SAAY,GACZ,KAAQ,IACR,GAAM,WACN,UAAa,IAAKD,MAAC,OAAO,yBAA8B,8DAAC,KAAKC,GAAKA,EAAE,OAAO,CAC9E,EAGa,CAAC,QAAMC,SAAM,EAAIL,GAAgBE,EAAK,4kBCzKtC,SAAM,k3BCEnB,MAAMI,EAAmB,GAMzB,SAASC,GAAS/Q,EAAOgR,EAAO,CAC5B,MAAO,CACH,UAAWC,EAASjR,EAAOgR,CAAK,EAAE,SAC1C,CACA,CAMA,SAASC,EAASjR,EAAOgR,EAAQlT,EAAM,CACnC,IAAIoT,EACJ,MAAMC,EAAc,IAAI,IACxB,SAASC,EAAIC,EAAW,CACpB,GAAIrS,EAAegB,EAAOqR,CAAS,IAC/BrR,EAAQqR,EACJH,GAAM,CACN,MAAMI,EAAY,CAACR,EAAiB,OACpC,UAAWS,KAAcJ,EACrBI,EAAW,KACXT,EAAiB,KAAKS,EAAYvR,CAAK,EAE3C,GAAIsR,EAAW,CACX,QAAStQ,EAAI,EAAGA,EAAI8P,EAAiB,OAAQ9P,GAAK,EAC9C8P,EAAiB9P,GAAG,GAAG8P,EAAiB9P,EAAI,EAAE,EAElD8P,EAAiB,OAAS,CAC7B,CACJ,CAER,CACD,SAASlM,EAAOlG,EAAI,CAChB0S,EAAI1S,EAAGsB,CAAK,CAAC,CAChB,CACD,SAASJ,EAAUnB,EAAK+S,EAAa1T,EAAM,CACvC,MAAMyT,EAAa,CAAC9S,EAAK+S,CAAU,EACnC,SAAY,IAAID,CAAU,EACtBJ,EAAY,OAAS,IACrBD,EAAOF,EAAMI,CAAG,GAAKtT,GAEzBW,EAAIuB,CAAK,EACF,IAAM,CACTmR,EAAY,OAAOI,CAAU,EACzBJ,EAAY,OAAS,IACrBD,IACAA,EAAO,KAEvB,CACK,CACD,MAAO,CAAE,MAAK,SAAQ,YAC1B,CACA,SAASO,GAAQC,EAAQhT,EAAIiT,EAAe,CACxC,MAAMC,EAAS,CAAC,MAAM,QAAQF,CAAM,EAC9BG,EAAeD,EACf,CAACF,CAAM,EACPA,EACAI,EAAOpT,EAAG,OAAS,EACzB,OAAOqS,GAASY,EAAgBP,GAAQ,CACpC,IAAIW,EAAS,GACb,MAAMC,EAAS,GACf,IAAIC,EAAU,EACVC,EAAUpU,EACd,MAAMqU,EAAO,IAAM,CACf,GAAIF,EACA,OAEJC,IACA,MAAME,EAAS1T,EAAGkT,EAASI,EAAO,GAAKA,EAAQZ,CAAG,EAC9CU,EACAV,EAAIgB,CAAM,EAGVF,EAAUpT,GAAYsT,CAAM,EAAIA,EAAStU,CAEzD,EACcuU,EAAgBR,EAAa,IAAI,CAACnS,EAAOsB,IAAMpB,GAAUF,EAAQM,GAAU,CAC7EgS,EAAOhR,GAAKhB,EACZiS,GAAW,EAAE,GAAKjR,GACd+Q,GACAI,GAEhB,EAAW,IAAM,CACLF,GAAY,GAAKjR,CACpB,EAAC,EACF,SAAS,GACTmR,IACO,UAAgB,CACnBvT,EAAQyT,CAAa,EACrBH,GACZ,CACA,CAAK,CACL,CCjGA,OAAO,QAAU,OAAO,SAAW,CAAE,EAG9B,MAAMI,EAAQrB,EAAS,IAAI,EAGrBJ,EAASI,EAAS,EAAE,EACjCJ,EAAO,UAAUA,GAAW,OAAO,QAAQ,OAASA,CAAO,EAEpD,IAAI0B,GAActB,EAAS,CAAE,UAAW,CAAE,OAAQ,CAAE,GAAI,EAGxD,MAAMuB,GAAWvB,EAAS,IAAI,EAIxBwB,GAAiBxB,EAAS,EAAI,EChBpC,eAAeyB,GAAa,CAAE,OAAM,WAAU,gBAAe,YAAU,EAAI,CAE9E,MAAM5H,EAAc6H,EAAK,OAASA,EAClC,WAAW,IAAM9H,GAAa+H,EAAY9H,CAAW,CAAC,EAEtD,KAAM,CAAE,MAAI,EAAK6H,EACX,CAAE,SAAS,EAAGzG,GAAiB,EAC/B2G,EAAa3K,EAAQ,SAE3B,UAAW4K,KAAQC,EAAc,OAEzBD,GAAM,MAAMA,EAAKH,EAAK,GAAG,EAGjCK,EAAS,OAAQ,EAEjB,cAAc,IAAI,YAAY,YAAY,CAAC,EAC3C,OAAO,YAAY,CACf,IAAK,aACL,WAAY,OAAO,QAAQ,WAC3B,OACA,YACH,EAAE,GAAG,EACN,OAAO,QAAW,UAAY,GAC9B,OAAO,QAAW,cAAgB,EACtC,CCnBO,SAASC,GAAW3T,EAAK8K,EAAQ,GAAO,CAC3C9K,EAAMiN,EAAO,aAAa,OAAOjN,CAAG,EACpC,GAAI,CAAE,WAAU,QAAM,EAAK+M,GAAS/M,CAAG,EAAE,IAGzC,MAAMuR,EAASqC,EAAIC,CAAa,EAC1BC,EAEFvC,EAAO,KAAKyB,GAASe,IAAaf,EAAM,KAAK,IAAI,GAEjDzB,EAAO,KAAKyB,GAASe,EAAS,MAAMf,EAAM,KAAK,CAAC,EAEpD,GAAI,CAACc,EACD,MAAM,IAAI,MAAM,iCAAiCC,KAAY,EAGjE,MAAMC,EAAiBlJ,EAAQ,OAAO,OAAOgJ,CAAa,EAAIA,EAExD,CAAE,QAAO,eAAc,aAAa,EAAGG,GAAiBD,EAAgBzC,CAAM,EAEpF,OAAI2C,IACC,CAAE,WAAU,QAAQ,EAAGnH,GAASM,GAAW6G,EAAalB,EAAM,MAAM,CAAC,EAAE,IACpEmB,IACAnB,EAAM,WAAa3F,GAAW8G,EAAcnB,EAAM,QAAU,EAAE,IAGlE/F,EAAO,eACP+F,EAAM,OAAS,OAAO,OAAO,GAAI/F,EAAO,aAAa,MAAMjC,CAAM,CAAC,GAEtEoJ,GAA8BpB,EAAOe,CAAQ,EAE7Cf,EAAM,SAAWhT,EAAI,QAAQ,IAAI,OAAOgT,EAAM,KAAK,EAAG,EAAE,EACjDA,CACX,CAEA,SAASoB,GAA8BpB,EAAOe,EAAU,CACpD,GAAIf,EAAM,UAAW,CACjB,MAAMzD,EAAU8E,GAAYrB,EAAM,OAAO,EACnCsB,EAAYP,EAAS,MAAM,GAAG,EAAE,OAAO,OAAO,EACjCQ,GAAcvB,EAAM,IAAI,EAEhC,QAAQ,CAACwB,EAAM,IAAM,CACxBA,IACAxB,EAAM,OAAOwB,GAAQF,EAAU,GAC3B/E,EAAQ,GAAIA,EAAQ,GAAG,MAAQ,CAAE,CAACiF,GAAOF,EAAU,EAAI,EACtDtB,EAAM,MAAQ,CAAE,CAACwB,GAAOF,EAAU,EAAI,EAE3D,CAAS,CACJ,CACL,CAQA,SAASL,GAAiBjB,EAAOzB,EAAQ4C,EAAcD,EAAa,CAChE,KAAM,CAAE,WAAU,SAAS,EAAGlB,EAAM,KAEpC,GAAIyB,GAAYC,EAAS,CACrBP,EAAeM,EAAWA,EAAS,MAAQA,EAAWN,EACtDD,EAAcQ,EAAUA,EAAQ,MAAQA,EAAUP,EAClD,MAAMQ,EAAiBF,GAAYA,EAAS,OACtCG,EAAgBF,GAAWA,EAAQ,OAEnCG,EAAWtD,EAAO,KAAKuD,GAAKA,EAAE,KAAK,QAAQ,WAAW,EAAE,IAAMZ,CAAW,EAE/E,OAAIW,IAAa7B,GAAO,QAAQ,MAAM,GAAGkB,4BAAsC,EAC1EW,GAAU,QAAQ,MAAM,GAAG7B,EAAM,6CAA6CkB,GAAa,GAC5FS,GAAkBC,KAClBC,EAAS,OAAS,OAAO,OAAO,CAAE,EAAEA,EAAS,OAAQF,EAAgBC,CAAa,GAE/EX,GAAiBY,EAAUtD,EAAQ4C,EAAcD,CAAW,CACtE,CACD,MAAO,CAAE,QAAO,eAAc,aAAa,CAC/C,CAMA,SAASG,GAAY9E,EAAS,CAC1B,MAAMwF,EAAM,CAAE,EACd,SAAQ,QAAQ1F,GAAU,CACtB0F,EAAI1F,EAAO,KAAK,MAAM,GAAG,EAAE,OAAO,OAAO,EAAE,OAAS,GAAKA,CACjE,CAAK,EACM0F,CACX,CAMA,SAASR,GAAcvU,EAAK,CACxB,OAAOA,EACF,MAAM,GAAG,EACT,OAAO,OAAO,EACd,IAAIgV,GAAKA,EAAE,MAAM,QAAQ,CAAC,EAC1B,IAAIA,GAAKA,GAAKA,EAAE,EAAE,CAC3B,oOC7BiBlV,gBAAS,GAAG,6HAAzB6J,EAAuEnH,4BAA1DlB,sBAAS,GAAG,kOADpBL,EAAQ,oBAAcA,EAAQ,GAAC,QAAQ,sCAA5C,OAAIS,kVADRiI,EAIKnH,6EAHIvB,EAAQ,yNA3ET,SAAY,EACZgU,GAAQ,CACZ,SAAU,GACV,QAAS,IACT,YAAa,KAITC,GAAQvD,EAAQ,IAChBwD,GAAUhD,GAAQ+C,GAAOE,GAAKA,EAAE,MAAM,EAAGC,EAAS,GACxDF,GAAQ,UAAUA,GAChBA,EAAQ,QAAO,EAAI,aAAO,CACxB,WAAU,IAAOG,GAAgB1M,EAAQ,QAAQ,EAAGA,EAAQ,OAAO,cAQvD2M,GAASjJ,EAAM1D,EAAO,IAQhC,GAPJ2M,GAAS,GAAKA,GAAS,IAAM,EAC7BjJ,EAAOA,EAAK,MAAQA,EAEpB1D,EAAO,IAAQqM,GAAQ,GAAKrM,CAAO,EACnCA,EAAQ,SAAW2M,GAAS,KAGxB,OAAO,QAAQ,YAAc,UAAU,UAAU,MAAM,OAAO,QACzD,GAGTL,GAAM,OAAOE,IACNA,EAAE,KAAKtR,GAAKA,EAAE,QAAQ,OAASwI,CAAI,GACtC8I,EAAE,KAAI,CACJ,IAAG,GAAK9I,+BAAkC,mBAAmB,KAAK,UAAU1D,CAAO,KACnF,YAEGwM,IAOF,YAAgBI,EAAS,OAC1BC,EAAKD,EAAU,KAAOA,EAAU,KAAK,WAAaA,EACnD,aAAW,KAEV,QAAQ5B,EAAIsB,EAAK,EAAE,KACvBQ,GAASA,GAASA,EAAM,QAAQ,UAAYD,MAI1CC,EAAK,OACC,aAAW,EAAKA,EAAM,QACxBC,EAAY,IAAO,QAAQ/E,GAC/B,WAAWA,EAASgF,CAAW,GAE3BC,EAAW,IAAO,QAAQjF,GAAO,CACrC,OAAO,oBACH,OAAO,oBAAoBA,CAAO,EAClC,WAAWA,EAASgF,EAAc,GAAI,IAE5C,QAAQ,IAAG,CAAED,EAAcE,CAAW,GAAG,KAAI,KAC3CX,GAAM,OAAOE,GAAKA,EAAE,OAAOA,GAAKA,EAAE,QAAQ,UAAYK,CAAE,MAM9D,iBAAiB,UAAWH,GAAiB,EAAK,gkBC1DpD,SAASQ,IAAoB,CAC3B,OAAOtR,GAAW,SAAS,GAAKyO,EAClC,CA4FO,MAAMQ,GAAgB,CAC3B,OAAQ,CACNsC,GAAS5C,GAAe,IAAI,EAAK,CAClC,EACD,UAAW6C,EACb,EASaC,GAAkB,CAC7B,OAAQ,CAAE,EACV,UAAWD,EACb,EAEA,SAASA,GAAYE,EAAU,CAC7B,MAAMC,EAAQ,KAAK,OACb5M,EAAQ4M,EAAM,OACpB,SAASrV,GAAY,CAACqV,EAAM5M,GAASzI,CAAQ,CAAC,EACvC,IAAIoK,IAAW,CACpB,OAAOiL,EAAM5M,GACb2M,EAAS,GAAGhL,CAAM,CACnB,CACH,CAmEY,MAAClL,GAAM,CACjB,UAAUkW,EAAU,CAClB,MAAMjV,EAAM6U,GAAmB,EAC/B,OAAO3D,GACLlR,EACAA,GAAOmV,GAAcnV,EAAKA,EAAI,MAAOA,EAAI,MAAM,CACrD,EAAM,UACAiV,CACD,CACF,CACH,EAQO,SAASE,GAAcC,EAAMC,EAAeC,EAAS,CAC1D,OAAO,SAAajK,EAAMpB,EAAS,GAAItC,EAAS,CAC9C,KAAM,CAAC,WAAS,EAAIyN,EACd/I,EAAkB,OAAO,OAAO,GAAIgJ,EAAc,OAAQzV,EAAU,MAAM,EAChF,IAAI+K,EAAKU,GAAQA,EAAK,UAAYA,EAE9BV,IACFU,EAAOA,EAAK,aAAa,MAAM,GAEjCA,EAAOA,EAAOkK,EAAYlK,CAAI,EAAIzL,EAAU,UAG5C,MAAMmS,EAAQuD,EAAQ,KAAKvD,GAAS,CAACA,EAAM,WAAa,IAAKA,EAAM,IAAI,EAAE,SAAS1G,CAAI,CAAC,EACvF,GAAI0G,GAASA,EAAM,KAAK,UAAY,aAAe,OAAO,oBAAqB,CAC7E,MAAMyD,EAAQ,QAAQ,UAAY,EAAI,KACtC,WAAW,IAAM,CACf,OAAO,oBAAoB,IAAMzD,EAAM,IAAI,QAAO,CAAE,CACrD,EAAEyD,CAAK,CACT,CAEc7N,GAAWA,EAAQ,SAAW,KAChC0D,EAAOA,EAAK,QAAQ,SAAU,EAAE,GAE7C,IAAItM,EAAMqN,GAAWf,EAAMpB,EAAQoC,CAAe,EAElD,GAAI1B,EACF,SAAG,KAAO5L,EACH,CACL,OAAO0W,EAAe,CAAC9K,EAAG,KAAOyB,GAAWf,EAAMoK,EAAepJ,CAAe,CAAC,CAClF,EAGH,OAAOtN,EAOP,SAASwW,EAAYlK,EAAM,CACzB,GAAIA,EAAK,MAAM,UAAU,EAAG,CAE1B,GAAI,EAAGqK,EAAaC,CAAY,EAAItK,EAAK,MAAM,gBAAgB,EAC3DuK,EAAMhW,EAAU,KAAK,QAAQ,MAAO,EAAE,EAC1C,MAAMiW,EAAWH,EAAY,MAAM,SAAS,GAAK,CAAE,EAE/C9V,EAAU,QAAQiW,EAAS,KAAK,IAAI,EACxCA,EAAS,QAAQ,IAAMD,EAAMA,EAAI,QAAQ,eAAgB,EAAE,CAAC,EAC5DvK,EAAO,GAAGuK,KAAOD,IAAe,QAAQ,MAAO,EAAE,EACjDtK,EAAOA,GAAQ,GAChB,SAAU,GAAK,MAAM,KAAK,EAEpB,CAEL,MAAMwH,EAAgByC,EAAQ,KAAKvD,GAASA,EAAM,KAAK,OAAS1G,CAAI,EAChEwH,IAAexH,EAAOwH,EAAc,UACzC,CACD,OAAOxH,CACR,CAIF,CACH,CAYY,MAACyK,GAAO,CAClB,UAAUb,EAAU,CAClB,MAAMc,EAAoBxS,GAAW,mBAAmB,EACxD,OAAO2N,GAAQnS,GACbA,GAAO,SAAcsM,EAAMpB,EAAQ+L,EAASC,EAAS,CACnD,MAAMC,EAAOnX,EAAIsM,EAAMpB,CAAM,EACxB+L,EACAD,EAAkBG,EAAMD,CAAO,EADtB,QAAQ,UAAU,CAAE,EAAE,KAAMC,CAAI,CAE/C,CACP,EAAM,UACAjB,CACD,CACF,CACH,EA8BakB,GAAW,CACtB,UAAUjY,EAAK,CACb,OAAOgT,GACL,CAACnS,GAAKgT,CAAK,EACX,CAAC,CAAChT,EAAKgT,CAAK,IAAM,SAAkB1G,EAAO,GAAIpB,EAAS,GAAI,CAAC,QAAM,EAAI,CAAC,OAAQ,EAAI,EAAG,CACrFoB,EAAOtM,EAAIsM,EAAMpB,EAAQ,CAAC,QAAM,CAAC,EACjC,MAAMmM,EAAcrX,EAAIgT,EAAM,KAAM9H,EAAQ,CAAC,QAAM,CAAC,EAC9CoM,EAAK,IAAI,OAAO,IAAMhL,EAAO,OAAO,EAC1C,MAAO,CAAC,CAAC+K,EAAY,MAAMC,CAAE,CAC9B,CACP,EAAM,UAAUnY,CAAG,CAChB,CACH,EA6EMoY,EAAY,CAChB,UAAUrB,EAAU,CAClB,YAAK,QAAU,KAAK,UAAW,EACxBA,EAASxC,EAAQ,CACzB,EACD,MAAO,CAAE,EACT,UAAW,CAAE,EACb,SAAU,CACR,MAAO,CAAC,UAAW,OAAQ,WAAY,SAAS,EAChD,QAAS,CAAC,UAAW,OAAQ,WAAY,SAAS,EAClD,GAAI,CAAC,UAAW,WAAY,WAAY,SAAS,CAClD,EACD,QAAS,CACP,CACE,KAAM,gBACN,UAAW,IAAM,GACjB,OAAQ,CAACc,EAAM9T,IAAU,CACvB,MAAM8W,EAAWD,EAAU,WAAWA,EAAU,UAAW/C,CAAI,IAAMrJ,GAAKA,GAC1E,MAAO,CAACqJ,EAAMgD,EAAS9W,CAAK,CAAC,CAC9B,CACF,EACD,CACE,KAAM,aACN,UAAW,IAAM,GACjB,OAAO8T,EAAM9T,EAAO,CAClB6W,EAAU,UAAU/C,EAAM9T,CAAK,CAChC,CACF,EACD,CACE,KAAM,WACN,UAAW8T,GAAQ,CAACA,EAAK,MAAM,GAAG,EAClC,OAAOA,EAAM9T,EAAO,CAClB6W,EAAU,UAAU,MAAM/C,IAAQ9T,CAAK,CACxC,CACF,EACD,CACE,KAAM,cACN,UAAW8T,GAAQA,IAAS,QAC5B,OAAOA,EAAM9T,EAAO,CAClB,SAAS,MAAQA,CAClB,CACF,CACF,EACD,WAAW+W,EAAMpX,EAAM,CACrB,MAAMqX,EAAYD,EAAKpX,GACvB,GAAIqX,EAAW,CACb,MAAML,EAAczD,EAAIZ,CAAK,EAAE,KAIzB2E,EAHW,OAAO,KAAKF,EAAKpX,EAAK,EACR,OAAOiM,GAAQ+K,EAAY,SAAS/K,CAAI,CAAC,EAEvC,KAAK,CAAC3M,EAAGC,IAAMA,EAAE,OAASD,EAAE,MAAM,EAAE,GAErE,OAAO+X,EAAUC,EAClB,CACF,EACD,UAAUnD,EAAM9T,EAAO,CACrB,MAAMkX,EAAO,SAAS,qBAAqB,MAAM,EAAE,GAC7CC,EAAQrD,EAAK,MAAM,QAAQ,EAC3BsD,EAAcD,GAASA,EAAM,IAAM,QACnC,CAAC,YAAW,YAAU,EAAInE,GAAS,SAASoE,IAAgBpE,GAAS,SAAS,MAC9EqE,EAAa,SAAS,cAAc,QAAQC,MAAcxD,KAAQ,EACpEuD,GAAYA,EAAW,OAAQ,EAEnC,MAAME,EAAa,SAAS,cAAc,MAAM,EAChDA,EAAW,aAAaD,EAAWxD,CAAI,EACvCyD,EAAW,aAAaC,EAAYxX,CAAK,EACzCuX,EAAW,aAAa,cAAe,SAAS,EAChDL,EAAK,YAAYK,CAAU,CAC5B,EACD,IAAIzD,EAAM9T,EAAO,CAEX,OAAO8T,GAAS,UAClB+C,EAAU,QAAQ,QAAQY,GAAU,CAC9BA,EAAO,UAAU3D,EAAM9T,CAAK,IAC9B,CAAC8T,EAAM9T,CAAK,EAAIyX,EAAO,OAAO3D,EAAM9T,CAAK,GAAK,CAAC8T,EAAM9T,CAAK,EACpE,CAAO,CAEJ,EACD,OAAQ,CACN,MAAMqX,EAAa,SAAS,cAAc,MAAM,EAC5CA,GAAYA,EAAW,OAAQ,CACpC,EACD,SAAS1X,EAAMjB,EAAI,CACjB,MAAM8N,EAASqK,EAAU,UACzBA,EAAU,UAAUlX,GAAQkX,EAAU,UAAUlX,IAAS,CAAE,EAC3DkX,EAAU,UAAUlX,GAAM6M,GAAU9N,CACrC,EACD,QAAS,CACP,OAAO,KAAKmY,EAAU,KAAK,EAAE,QAAS/C,GAAS,CAC7C,IAAI9T,EAAS6W,EAAU,WAAWA,EAAU,MAAO/C,CAAI,EACvD+C,EAAU,QAAQ,QAAQY,GAAU,CAC9BA,EAAO,UAAU3D,EAAM9T,CAAK,IAC9B,CAAC8T,EAAM9T,CAAK,EAAIyX,EAAO,OAAO3D,EAAM9T,CAAK,GAAK,CAAC8T,EAAM9T,CAAK,EAGpE,CAAO,CACP,CAAK,CACF,EACD,eAAgB,CACT6W,EAAU,iBACbA,EAAU,eAAiB,GAC3B,WAAW,IAAM,CACfA,EAAU,eAAiB,GAC3B,KAAK,OAAQ,CACrB,CAAO,EAEJ,EACD,cAAe,GACf,QAAS,GACT,WAAY,CACV,GAAI,KAAK,QAAS,OAAO,KAAK,QAC9B,MAAMa,EAAatC,GAAmB,EACtC,OAAOsC,GAAcxE,EAAIwE,CAAU,EAAE,MAAQ,GAC9C,EACD,eAAgB,EAClB,EAOa1E,GAAW,IAAI,MAAM6D,EAAW,CAC3C,IAAI/U,EAAQnC,EAAMK,EAAO2X,EAAU,CACjC,KAAM,CAAC,OAAK,EAAI7V,EAEhB,OAAI,QAAQ,IAAIA,EAAQnC,CAAI,EAC1B,QAAQ,IAAImC,EAAQnC,EAAMK,EAAO2X,CAAQ,GAEzCrP,EAAM3I,GAAQ2I,EAAM3I,IAAS,CAAE,EAC/B2I,EAAM3I,GAAMmC,EAAO,UAAS,GAAM9B,GAGhC,OAAO,QAAW,WACpB8B,EAAO,cAAe,EACjB,EACR,CACH,CAAC,4PC1cSvB,EAAQ,qBAAqDA,EAAE,+OAA/DA,EAAQ,kaAcOA,EAAM,MAAKA,EAAY,6LAAvBA,EAAM,MAAKA,EAAY,4QAJnCA,EAAS,KAAIA,EAAK,GAAC,QAAMqX,wGAAzBrX,EAAS,KAAIA,EAAK,GAAC,whBAFpBA,KAAK,OAAK,UALRA,EAAa,uDACPsX,EAAY,qCAAZA,EAAY,2TAIpBjX,aAAK,OAAK,4DALRL,EAAa,wcAFCA,EAAS,mWAATA,EAAS,8jBAuBnC0I,EAAkDnH,iNAzB/CvB,EAAQ,aAwBPA,EAAU,iRAxBXA,EAAQ,2GAwBPA,EAAU,wZA5GH,QAAK,OACL,SAAM,MACN,aAAY,UAGnB7C,EAAO,KACPoa,EAAiB,KACjBC,EAAU,GACVnF,EACApB,EAAa,QAEX3N,EAAUoN,EAAS,IAAI,oCAEvB,QAAgBnN,GAAW,SAAS,GAAKyO,4CACzC,QAAiBrH,GAAE8M,IAAKpF,EAAa1H,EAAG,YAE9CtH,GAAW,UAAWC,CAAO,MAEzBoU,EAAS,GAQJ,WAAava,EAAI,KACpBwa,EAAmBxa,EAAK,YACxBwa,aAA4B,QAC9BA,EAAiB,KAAKC,CAAiB,EACpCA,EAAkBD,CAAgB,EAKhC,WAAkBE,EAAa,CACtCJ,UAAkBK,CAAM,SAIlB9X,EAAG,IAEJ+X,EACH,MAAOR,EACP,UAAWS,GAAaC,GACxB,OAAQ9a,EAAK,SAAWA,EAAO+a,EAAe,OAC9C,UAAW/a,EACX,MAAOgb,EACP,OAAQ7C,EACR,gBACA,WAAYjD,GAAc6F,EAAe,YAE3C5U,EAAQ,IAAItD,CAAG,OACfkY,EAAe,MAAQ/a,KACnBoa,EAAe,SAAW,GAAGa,EAAqB,iBAGzCA,GAAqB,CACxB,kBAASzI,GAAY,WAAWA,CAAO,SAC3C0I,EAAmBN,EAAS,UAAU,OAASI,EAAO,KAGvD,QAAO,QAAW,eAAiBE,GACtClG,GAAY,CACV,KAAM4F,EAAS,UACf,YACA,iBACA,eAKG,YAAQ,OAAM,OAAM,SAAO,SAAM,GACjC,YAAK,UAAS,CACnB,OACA,aACA,OAAQ7K,EAAK,kBAAoBA,EAAK,kBAAoBoL,GAC1D,YAAapL,EAAK,yBAA2BjD,qrCA1D1CyN,IAActP,IACnBqP,OAAYrP,QACVjL,EAAI,GAAKoa,CAAc,MAAQnP,CAAK,KACtCqP,MAAK,IAAO,eAAcxG,IAAUA,qBAUnCsH,EAAapb,CAAI,mBAgDnBsa,IAAEjD,EAAKuD,GAAY9G,GAAcuH,EAAMT,EAAS,SAAS,kBACvDA,GAAYzM,GAA0ByM,EAAU/T,EAAI,utCCnGlD,SAAS0D,GAAK4I,EAAQzQ,EAAU,CAErC,IAAI4Y,EAAY,GAEhB,SAASC,EAAWC,EAAY1C,EAAS,CACvC,MAAMlX,EAAM4Z,GAAchN,GAAe,EAAG,SACtCoG,EAAQW,GAAW3T,CAAG,EACxBgT,EAAM,aACR,QAAQ,mBAAmB,GAAI,KAAMA,EAAM,UAAU,EACrD,OAAOA,EAAM,YAKf,MAAM3J,EAAQ,CAAC,IAFM6N,GAAWvD,GAAW/G,GAAiB,EAAC,SAAU2E,CAAM,GACxCyB,GACN,QAASA,CAAK,EACzC0G,GAAW,OAAOA,EAAU,KAChC1G,EAAM,KAAO0G,EACbA,EAAY1G,EAGP4G,GACHC,GAAgB,IAAI7G,CAAK,EAC3B8G,EAAa,IAAI9G,CAAK,EAGtBA,EAAM,IAAI,QAAS,EAAC,KAAK,IAAM,CAE7B+G,GAAsB,IAAI,EAAI,EAC9BjZ,EAASuI,CAAK,CACpB,CAAK,CACF,CAED,MAAM5C,EAAUuT,GAAqBL,CAAU,EAE/C,MAAO,CAAE,aAAY,SAAS,CAChC,CAMA,SAASK,GAAqBL,EAAY,CAEvC,CAAC,YAAa,cAAc,EAAE,QAAQM,GAAa,CAC7C,QAAQA,EAAY,YACvB,QAAQA,EAAY,UAAY,QAAQA,IAC1C,QAAQA,GAAa,eAAgBC,EAAQ,CAAE,EAAEC,EAAOna,EAAK,CAE3D,MAAMoa,EAAa,SAAS,SAAW,SAAS,OAAS,SAAS,KAClE,GAAIpa,IAAQoa,EAAY,MAAO,GAE/B,KAAM,CAAE,KAAI,OAAM,QAAM,EAAKxG,EAAIkG,CAAY,EAC7CI,EAAQ,CAAE,KAAI,OAAM,SAAQ,GAAGA,CAAO,EACtC,MAAMnE,EAAQ,IAAI,MAAMkE,EAAU,YAAW,CAAE,EAI/C,GAHA,OAAO,OAAOlE,EAAO,CAAE,QAAO,QAAO,MAAK,EAE5B,MAAMsE,GAAwBtE,EAAO/V,CAAG,EAEpD,eAAQia,EAAY,UAAU,MAAM,KAAM,CAACC,EAAOC,EAAOna,CAAG,CAAC,EACtD,cAAc+V,CAAK,CAE7B,CACL,CAAG,EAED,IAAIuE,EAAiB,GAErB,MAAMC,EAAY,CAChB,MAAOC,GACP,UAAW,IAAMb,EAAY,EAC7B,aAAc,IAAMA,EAAY,EAChC,SAAU,MAAM5D,GAAS,CACnBuE,EACFA,EAAiB,GAEb,MAAMD,GAAwBtE,EAAOnJ,GAAiB,EAAC,QAAQ,EACjE+M,EAAY,GAEZW,EAAiB,GACjBvE,EAAM,eAAgB,EACtB,QAAQ,GAAG,CAAC,EAGjB,CACF,EAED,cAAO,QAAQwE,CAAS,EAAE,QAAQ7N,GAAQ,iBAAiB,GAAGA,CAAI,CAAC,EAEhD,IAAM,CACvB,OAAO,QAAQ6N,CAAS,EAAE,QAAQ7N,GAAQ,oBAAoB,GAAGA,CAAI,CAAC,CACvE,CAGH,CAEA,SAAS8N,GAAYzE,EAAO,CAC1B,MAAMnK,EAAKmK,EAAM,OAAO,QAAQ,GAAG,GAAKA,EAAM,aAAY,EAAG,KAAKnK,GAAMA,EAAG,UAAY,GAAG,EACpFuL,EAAOvL,GAAMA,EAAG,KAUtB,GAREmK,EAAM,SACNA,EAAM,SACNA,EAAM,QACNA,EAAM,UACNA,EAAM,QACNA,EAAM,kBAGJ,CAACoB,GAAQvL,EAAG,QAAUA,EAAG,OAAS,SAAS,KAAM,OAErD,MAAM5L,EAAM,IAAI,IAAImX,CAAI,EAClBsD,EAAcza,EAAI,SAAWA,EAAI,OAASA,EAAI,KAEpD+V,EAAM,eAAgB,EACtB,QAAQ,UAAU,GAAI,GAAI0E,CAAW,CACvC,CAEA,eAAeJ,GAAwBtE,EAAO/V,EAAK,CACjD,MAAMgT,EAAQW,GAAW3T,CAAG,EAAE,IAC9B,UAAWwT,KAAQyC,GAAgB,OAAO,OAAO,OAAO,EAGtD,GAAI,CADW,MAAMzC,EAAKuC,EAAO/C,EAAO,CAAE,MAAK,EAClC,MAAO,GAEtB,MAAO,EACT,mdCxEK/R,EAAK,IAAIA,EAAM,KAAK,MAAIyZ,0RAAxBzZ,EAAK,IAAIA,EAAM,KAAK,wbAjDZsQ,aACA,SAAM,MAEblI,EACAsR,EAEJ,OAAO,QAAU,OAAO,SAAO,GAC/B,OAAO,QAAQ,UAAa,QAAO,UAAU,UAAU,MAAM,OAAO,EAEpE,OAAO,OAAO5P,EAAekC,CAAM,QAE7B0M,EAAU,IAAOjN,IAASiO,GAAaA,EAAU,WAAU,GAAIjO,CAAI,EAEzEpI,GAAW,oBAAqBqV,CAAU,EAEpC,QAAW9I,GAAQ6H,MAAQ7H,CAAG,EAE9B+B,EAAO,MACN+H,IACLA,EAAU,QAAO,EACjBA,EAAY,OAGV,MAAc,WAWZC,EAAM,KACV,aAAaC,CAAW,EACxBA,EAAc,WAAU,KACtBjI,IACA+H,EAAYhS,GAAK4I,EAAQzQ,CAAQ,EACjCga,EAAY,IAAIvJ,CAAM,EACtBoJ,EAAU,WAAU,KAMxBtW,GAAUuO,CAAO,w3BAFVrB,GAAQqJ,ktDCjDL,IAAIG,GAAI,CAClB,OAAQ,SAAS,eAAe,KAAK,CACvC,CAAC","names":["relList","link","processPreload","mutations","mutation","node","getFetchOpts","script","fetchOpts","noop","assign","tar","src","k","add_location","element","file","line","column","char","run","fn","blank_object","run_all","fns","is_function","thing","safe_not_equal","a","b","src_url_equal_anchor","src_url_equal","element_src","url","is_empty","obj","validate_store","store","name","subscribe","callbacks","unsub","get_store_value","value","_","component_subscribe","component","callback","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","get_slot_changes","dirty","lets","merged","len","i","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","get_all_dirty_from_scope","length","set_store_value","ret","action_destroyer","action_result","append","target","insert","anchor","detach","destroy_each","iterations","detaching","text","data","space","empty","attr","attribute","children","set_style","key","important","toggle_class","toggle","custom_event","type","detail","e","bubbles","cancelable","current_component","set_current_component","get_current_component","onMount","onDestroy","setContext","context","getContext","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","update_scheduled","schedule_update","flush","tick","add_render_callback","seen_callbacks","flushidx","saved_component","update","$$","outroing","outros","group_outros","check_outros","transition_in","block","local","transition_out","globals","destroy_block","lookup","outro_and_destroy_block","update_keyed_each","old_blocks","get_key","dynamic","list","destroy","create_each_block","next","get_context","o","n","old_indexes","new_blocks","new_lookup","deltas","child_ctx","will_move","did_move","new_block","old_block","new_key","old_key","validate_each_keys","keys","get_spread_update","levels","updates","to_null_out","accounted_for","get_spread_object","spread_props","create_component","mount_component","customElement","fragment","new_on_destroy","after_update","destroy_component","make_dirty","init","options","instance","create_fragment","not_equal","props","append_styles","parent_component","ready","rest","nodes","SvelteComponent","index","$$props","dispatch_dev","append_dev","insert_dev","detach_dev","attr_dev","validate_each_argument","arg","msg","validate_slots","slot_key","construct_svelte_component_dev","error_message","err","message","SvelteComponentDev","createNodeMiddleware","inner","payload","nodeMiddleware","nodeMiddlewareSync","_file","clone","defaultConfig","search","fromEntries","params","x","iterable","val","MATCH_PARAM","handleScroll","scrollToTop","scrollAncestorsToTop","handleHash","hash","el","pathToRegex","str","recursive","suffix","pathToParamKeys","string","paramsKeys","matches","pathToRank","path","suppressComponentWarnings","ignores","log","args","_console","currentLocation","dirtyFullpath","resolvePrefetch","parseUrl","_options","config","origin","_url","fullpath","resolveUrl","inheritedParams","populateUrl","allParams","queryString","getQueryString","ignoredKeys","queryParams","setRegex","setParamKeys","setShortPath","setRank","addMetaChildren","metaChildren","meta","setIsIndexable","isDynamic","isIndex","isIndexed","isHidden","isFallback","assignRelations","parent","_getSibling","_getLineage","lineage","direction","siblings","c","assignIndex","assignLayout","getLayouts","layout","isReset","layouts","createFlatList","treePayload","p","setPrototype","Prototype","Root","PageDir","Dir","Reset","Layout","Fallback","Page","defaultNode","restoreDefaults","assignAPI","ClientApi","_prettyName","api","_navigate","filePromises","resolve","res","child","plugins","miscPlugins","tree","buildClientTree","order","_tree","__vitePreload","m","routes","subscriber_queue","readable","start","writable","stop","subscribers","set","new_value","run_queue","subscriber","invalidate","derived","stores","initial_value","single","stores_array","auto","inited","values","pending","cleanup","sync","result","unsubscribers","route","rootContext","urlRoute","isChangingPage","onPageLoaded","page","parentNode","prefetchId","hook","afterPageLoad","metatags","urlToRoute","get","stores.routes","matchingRoute","pathname","_matchingRoute","resolveRedirects","rewritePath","redirectPath","assignParamsToRouteAndLayouts","layoutByPos","fragments","getRouteProps","prop","redirect","rewrite","redirectParams","rewriteParams","newRoute","r","arr","f","defaults","queue","actives","q","iframeNum","removeFromQueue","prefetch","idOrEvent","id","entry","gracePromise","gracePeriod","idlePromise","getRoutifyContext","event","hookHandler","beforeUrlChange","listener","hooks","makeUrlHelper","$ctx","$currentRoute","$routes","resolvePath","delay","changedParams","breadcrumbs","relativePath","dir","traverse","goto","routifyUpdatePage","_static","shallow","href","isActive","currentPath","re","_metatags","template","repo","providers","longestKey","head","match","serviceName","oldElement","propField","newElement","valueField","plugin","routifyCtx","receiver","create_if_block_2","scopeToChild","remainingNodes","scopedSync","$$invalidate","lastNodes","PendingComponent","onComponentLoaded","componentFile","scoped","$context","decorator","Noop","$parentContext","$route","onLastComponentLoaded","isOnCurrentRoute","param","setComponent","getID","lastRoute","updatePage","proxyToUrl","stores.urlRoute","stores.route","stores.isChangingPage","createEventListeners","eventName","state","title","currentUrl","runHooksBeforeUrlChange","_ignoreNextPop","listeners","handleClick","relativeUrl","create_if_block","navigator","doInit","initTimeout","routesStore","App"],"sources":["../../vite/modulepreload-polyfill","../../node_modules/svelte/internal/index.mjs","../../node_modules/@roxi/routify/runtime/middleware.js","../../node_modules/@roxi/routify/runtime.config.js","../../node_modules/@roxi/routify/runtime/utils/index.js","../../node_modules/@roxi/routify/runtime/plugins/tree.js","../../node_modules/@roxi/routify/runtime/utils/normalizeNode.js","../../node_modules/@roxi/routify/runtime/plugins/assignAPI.js","../../node_modules/@roxi/routify/runtime/buildRoutes.js","../../.routify/routes.js","../../node_modules/@roxi/routify/runtime/decorators/Noop.svelte","../../node_modules/svelte/store/index.mjs","../../node_modules/@roxi/routify/runtime/store.js","../../node_modules/@roxi/routify/runtime/utils/onPageLoaded.js","../../node_modules/@roxi/routify/runtime/utils/urlToRoute.js","../../node_modules/@roxi/routify/runtime/Prefetcher.svelte","../../node_modules/@roxi/routify/runtime/helpers.js","../../node_modules/@roxi/routify/runtime/Route.svelte","../../node_modules/@roxi/routify/runtime/navigator.js","../../node_modules/@roxi/routify/runtime/Router.svelte","../../src/main.ts"],"sourcesContent":["__VITE_IS_MODERN__&&(function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n}());","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            else\n                this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'itemscope',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${style_object[key]};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.52.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","/** \n * Node payload\n * @typedef {Object} NodePayload\n * @property {RouteNode=} file current node\n * @property {RouteNode=} parent parent of the current node\n * @property {StateObject=} state state shared by every node in the walker\n * @property {Object=} scope scope inherited by descendants in the scope\n *\n * State Object\n * @typedef {Object} StateObject\n * @prop {TreePayload=} treePayload payload from the tree\n * \n * Node walker proxy\n * @callback NodeWalkerProxy\n * @param {NodePayload} NodePayload\n */\n\n\n/**\n * Node middleware\n * @description Walks through the nodes of a tree\n * @example middleware = createNodeMiddleware(payload => {payload.file.name = 'hello'})(treePayload))\n * @param {NodeWalkerProxy} fn \n */\nfunction createNodeMiddleware(fn) {\n\n    /**    \n     * NodeMiddleware payload receiver\n     * @param {TreePayload} payload\n     */\n    const inner = async function execute(payload) {\n        return await nodeMiddleware(fn, {\n            file: payload.tree,\n            state: { treePayload: payload },\n            scope: {}\n        })\n    }\n\n    /**    \n     * NodeMiddleware sync payload receiver\n     * @param {TreePayload} payload\n     */\n    inner.sync = function executeSync(payload) {\n        return nodeMiddlewareSync(fn, {\n            file: payload.tree,\n            state: { treePayload: payload },\n            scope: {}\n        })\n    }\n\n    return inner\n}\n\n/**\n * Node walker\n * @param {NodeWalkerProxy} fn function to be called for each file\n * @param {NodePayload=} payload \n */\nasync function nodeMiddleware(fn, payload) {\n    const _file = await fn(payload)\n    if (_file === false) return false\n    const file = _file || payload.file\n\n    if (file.children) {\n        const children = await Promise.all(file.children.map(async _file => nodeMiddleware(fn, {\n            state: payload.state,\n            scope: clone(payload.scope || {}),\n            parent: payload.file,\n            file: await _file\n        })))\n        file.children = children.filter(Boolean)\n    }\n\n    return file\n}\n\n/**\n * Node walker (sync version)\n * @param {NodeWalkerProxy} fn function to be called for each file\n * @param {NodePayload=} payload \n */\nfunction nodeMiddlewareSync(fn, payload) {\n    const _file = fn(payload)\n    if (_file === false) return false\n\n    const file = _file || payload.file\n\n    if (file.children) {\n        const children = file.children.map(_file => nodeMiddlewareSync(fn, {\n            state: payload.state,\n            scope: clone(payload.scope || {}),\n            parent: payload.file,\n            file: _file\n        }))\n        file.children = children.filter(Boolean)\n    }\n\n    return file\n}\n\n\n/**\n * Clone with JSON\n * @param {T} obj \n * @returns {T} JSON cloned object\n * @template T\n */\nfunction clone(obj) { return JSON.parse(JSON.stringify(obj)) }\n\nexport {\n    nodeMiddleware,\n    nodeMiddlewareSync,\n    createNodeMiddleware\n}\n","export default {\n    queryHandler: {\n        parse: search => fromEntries(new URLSearchParams(search)),\n        stringify: params => '?' + (new URLSearchParams(params)).toString()\n    },\n    urlTransform: {\n        apply: x => x,\n        remove: x => x\n    },\n    useHash: false\n}\n\n\nfunction fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n        obj[key] = val\n        return obj\n    }, {})\n}","import config from '../../runtime.config'\n\nconst MATCH_PARAM = RegExp(/\\:([^/()]+)/g)\n\nexport function handleScroll(element, scrollToTop) {\n  if (navigator.userAgent.includes('jsdom')) return false\n  if (scrollToTop) scrollAncestorsToTop(element)\n  handleHash()\n}\n\nexport function handleHash() {\n  if (navigator.userAgent.includes('jsdom')) return false\n  const { hash } = window.location\n  if (hash) {\n    const el = document.getElementById(hash.substring(1))\n    if (el) el.scrollIntoView()\n  }\n}\n\nexport function scrollAncestorsToTop(element) {\n  if (\n    element &&\n    element.scrollTo &&\n    element.dataset.routify !== 'scroll-lock' &&\n    element.dataset['routify-scroll'] !== 'lock'\n  ) {\n    element.style['scroll-behavior'] = 'auto'\n    element.scrollTo({ top: 0, behavior: 'auto' })\n    element.style['scroll-behavior'] = ''\n    scrollAncestorsToTop(element.parentElement)\n  }\n}\n\nexport const pathToRegex = (str, recursive) => {\n  const suffix = recursive ? '' : '/?$' //fallbacks should match recursively\n  str = str.replace(/\\/_fallback?$/, '(/|$)')\n  str = str.replace(/\\/index$/, '(/index)?') //index files should be matched even if not present in url\n  str = str.replace(MATCH_PARAM, '([^/]+)') + suffix\n  str = `^${str}`\n  return str\n}\n\nexport const pathToParamKeys = string => {\n  const paramsKeys = []\n  let matches\n  while ((matches = MATCH_PARAM.exec(string))) paramsKeys.push(matches[1])\n  return paramsKeys\n}\n\nexport const pathToRank = ({ path }) => {\n  return path\n    .split('/')\n    .filter(Boolean)\n    .map(str => (str === '_fallback' ? 'A' : str.startsWith(':') ? 'B' : 'C'))\n    .join('')\n}\n\n/** Supresses Routify caused logs and warnings for one tick */\nexport function suppressComponentWarnings(ctx, tick) {\n  suppressComponentWarnings._console = suppressComponentWarnings._console || { log: console.log, warn: console.warn }\n  const { _console } = suppressComponentWarnings\n\n  const name = ctx.componentFile.name\n    .replace(/Proxy<_?(.+)>/, '$1') //nollup wraps names in Proxy<...>\n    .replace(/^Index$/, ctx.component.shortPath.split('/').pop()) //nollup names Index.svelte index. We want a real name\n    .replace(/^./, s => s.toUpperCase()) //capitalize first letter\n    .replace(/\\:(.+)/, 'U5B$1u5D') // :id => U5Bidu5D\n\n  const ignores = [\n    `<${name}> received an unexpected slot \"default\".`,\n    `<${name}> was created with unknown prop 'scoped'`,\n    `<${name}> was created with unknown prop 'scopedSync'`,\n  ]\n  for (const log of ['log', 'warn']) {\n    console[log] = (...args) => {\n      if (!ignores.includes(args[0]))\n        _console[log](...args)\n    }\n    tick().then(() => {\n      //after component has been created, we want to restore the console method (log or warn)\n      console[log] = _console[log]\n    })\n  }\n}\n\nexport function currentLocation() {\n  let dirtyFullpath = window.location.pathname + window.location.search + window.location.hash\n  const { url, options } = resolvePrefetch(dirtyFullpath)\n  const parsedUrl = parseUrl(url)\n\n  return { ...parsedUrl, options }\n}\n\n/**\n * converts /path/to__routify_url_options__1234abcde to\n * {options, url: '/path/to'}\n * @param {string} dirtyFullpath \n */\nfunction resolvePrefetch(dirtyFullpath) {\n  const [url, _options] = dirtyFullpath.split('__[[routify_url_options]]__')\n\n  const options = JSON.parse(decodeURIComponent(_options || '') || '{}')\n\n  window.routify = window.routify || {}\n  window.routify.prefetched = options.prefetch\n\n  return { url, options }\n}\n\n/**\n * \n * @param {string} url \n */\nexport function parseUrl(url) {\n  if (config.useHash)\n    url = url.replace(/.*#(.+)/, '$1')\n  const origin = url.startsWith('/') ? window.location.origin : undefined\n  const _url = new URL(url, origin)\n  const fullpath = _url.pathname + _url.search + _url.hash\n  return { url: _url, fullpath }\n}\n\n\n/**\n * populates parameters, applies urlTransform, prefixes hash\n * eg. /foo/:bar to /foo/something or #/foo/something\n * and applies config.urlTransform\n * @param {*} path \n * @param {*} params \n */\nexport function resolveUrl(path, params, inheritedParams) {\n  const hash = config.useHash ? '#' : ''\n  let url\n  url = populateUrl(path, params, inheritedParams)\n  url = config.urlTransform.apply(url)\n  url = hash + url\n  return url\n}\n\n\n/**\n * populates an url path with parameters\n * populateUrl('/home/:foo', {foo: 'something', bar:'baz'})  to /foo/something?bar=baz\n * @param {*} path \n * @param {*} params \n */\nexport function populateUrl(path, params, inheritedParams) {\n  const allParams = Object.assign({}, inheritedParams, params)\n  const queryString = getQueryString(path, params)\n\n  for (const [key, value] of Object.entries(allParams))\n    path = path.replace(`:${key}`, value)\n\n  return `${path}${queryString}`\n}\n\n\n/**\n * \n * @param {string} path \n * @param {object} params \n */\nfunction getQueryString(path, params) {\n  if (!config.queryHandler) return \"\"\n  const ignoredKeys = pathToParamKeys(path)\n  const queryParams = {}\n  if (params) Object.entries(params).forEach(([key, value]) => {\n    if (!ignoredKeys.includes(key))\n      queryParams[key] = value\n  })\n  return config.queryHandler.stringify(queryParams).replace(/\\?$/, '')\n}","import { createNodeMiddleware } from '../middleware'\nimport { pathToParamKeys, pathToRank, pathToRegex } from '../utils'\n\nexport const setRegex = createNodeMiddleware(({ file }) => {\n    if (file.isPage || file.isFallback)\n        file.regex = pathToRegex(file.path, file.isFallback)\n})\nexport const setParamKeys = createNodeMiddleware(({ file }) => {\n    file.paramKeys = pathToParamKeys(file.path)\n})\n\nexport const setShortPath = createNodeMiddleware(({ file }) => {\n    if (file.isFallback || file.isIndex)\n        file.shortPath = file.path.replace(/\\/[^/]+$/, '')\n    else file.shortPath = file.path\n})\nexport const setRank = createNodeMiddleware(({ file }) => {\n    file.ranking = pathToRank(file)\n})\n\n\n// todo delete?\nexport const addMetaChildren = createNodeMiddleware(({ file }) => {\n    const node = file\n    const metaChildren = file.meta && file.meta.children || []\n    if (metaChildren.length) {\n        node.children = node.children || []\n        node.children.push(...metaChildren.map(meta => ({ isMeta: true, ...meta, meta })))\n    }\n})\n\nexport const setIsIndexable = createNodeMiddleware(payload => {\n    const { file } = payload\n    const { isFallback, meta } = file\n    const isDynamic = file.path.split('/').pop().startsWith(':')\n    const isIndex = file.path.endsWith('/index')\n    const isIndexed = meta.index || meta.index === 0\n    const isHidden = meta.index === false\n\n    file.isIndexable = isIndexed || (!isFallback && !isDynamic && !isIndex && !isHidden)\n    file.isNonIndexable = !file.isIndexable\n})\n\nexport const assignRelations = createNodeMiddleware(({ file, parent }) => {\n    Object.defineProperty(file, 'parent', { get: () => parent })\n    Object.defineProperty(file, 'nextSibling', { get: () => _getSibling(file, 1) })\n    Object.defineProperty(file, 'prevSibling', { get: () => _getSibling(file, -1) })\n    Object.defineProperty(file, 'lineage', { get: () => _getLineage(parent) })\n})\n\nfunction _getLineage(node, lineage = []) {\n    if (node) {\n        lineage.unshift(node)\n        _getLineage(node.parent, lineage)\n    }\n    return lineage\n}\n\n/**\n * \n * @param {RouteNode} file \n * @param {Number} direction \n */\nfunction _getSibling(file, direction) {\n    if (!file.root) {\n        const siblings = file.parent.children.filter(c => c.isIndexable)\n        const index = siblings.indexOf(file)\n        return siblings[index + direction]\n    }\n}\n\nexport const assignIndex = createNodeMiddleware(({ file, parent }) => {\n    if (file.isIndex) Object.defineProperty(parent, 'index', { get: () => file })\n})\n\nexport const assignLayout = createNodeMiddleware(({ file, scope }) => {\n    // create a layouts getter\n    Object.defineProperty(file, 'layouts', { get: () => getLayouts(file) })\n\n    /**\n     * returns a list of layouts by recursively traversing the AST ancestry\n     * @param {RouteNode} file \n     * @returns {RouteNode[]}\n     */\n    function getLayouts(file) {\n        // if this isn't a layout and it's reset, return an empty array\n        if (!file.isLayout && file.meta.reset) return []\n\n        const { parent } = file\n        const layout = parent && parent.component && parent\n        const isReset = layout && (layout.isReset || layout.meta.reset)\n        const layouts = (parent && !isReset && getLayouts(parent)) || []\n        if (layout) layouts.push(layout)\n        return layouts\n    }\n})\n\n\nexport const createFlatList = treePayload => {\n    createNodeMiddleware(payload => {\n        if (payload.file.isPage || payload.file.isFallback)\n            payload.state.treePayload.routes.push(payload.file)\n    }).sync(treePayload)\n    treePayload.routes.sort((c, p) => (c.ranking >= p.ranking ? -1 : 1))\n}\n\nexport const setPrototype = createNodeMiddleware(({ file }) => {\n    const Prototype = file.root\n        ? Root\n        : file.children\n            ? file.isPage ? PageDir : Dir\n            : file.isReset\n                ? Reset\n                : file.isLayout\n                    ? Layout\n                    : file.isFallback\n                        ? Fallback\n                        : Page\n    Object.setPrototypeOf(file, Prototype.prototype)\n\n    function Layout() { }\n    function Dir() { }\n    function Fallback() { }\n    function Page() { }\n    function PageDir() { }\n    function Reset() { }\n    function Root() { }\n})\n","export const defaultNode = {\n    \"isDir\": false,\n    \"ext\": \"svelte\",\n    \"isLayout\": false,\n    \"isReset\": false,\n    \"isIndex\": false,\n    \"isFallback\": false,\n    \"isPage\": false,\n    \"ownMeta\": {},\n    \"meta\": {\n        \"recursive\": true,\n        \"preload\": false,\n        \"prerender\": true\n    },\n    \"id\": \"__fallback\",\n}\n\nconst devProps = [\n    'file', 'filepath', 'name', 'badExt', 'relativeDir', 'absolutePath',\n    'importPath', 'isFile'\n]\n\n/** @param {TreePayload} node  */\nexport function stripDefaultsAndDevProps(node) {\n    const strippedNode = {}\n\n    Object.entries(node)\n        .filter(([key]) => !devProps.includes(key))\n        .filter(([key, value]) => JSON.stringify(defaultNode[key]) !== JSON.stringify(value))\n        .forEach(([key, value]) => strippedNode[key] = value)\n\n    if (node.children)\n        strippedNode.children = [...node.children.map(stripDefaultsAndDevProps)]\n\n    return strippedNode\n}\n\nexport function restoreDefaults(node) {\n    Object.entries(defaultNode).forEach(([key, value]) => {\n        if (typeof node[key] === 'undefined')\n            node[key] = value\n    })\n    \n    if(node.children)\n        node.children = node.children.map(restoreDefaults)\n\n    return node\n}","import { createNodeMiddleware } from '../middleware'\nexport const assignAPI = createNodeMiddleware(({ file }) => {\n    file.api = new ClientApi(file)\n})\n\nclass ClientApi {\n    constructor(file) {\n        this.__file = file\n        Object.defineProperty(this, '__file', { enumerable: false })\n        this.isMeta = !!file.isMeta\n        this.path = file.path\n        this.title = _prettyName(file)\n        this.meta = file.meta\n    }\n\n    get parent() { return !this.__file.root && this.__file.parent.api }\n    get children() {\n        return (this.__file.children || this.__file.isLayout && this.__file.parent.children || [])\n            .filter(c => !c.isNonIndexable)\n            .sort((a, b) => {\n                if (a.isMeta && b.isMeta) return 0\n                a = (a.meta.index || a.meta.title || a.path).toString()\n                b = (b.meta.index || b.meta.title || b.path).toString()\n                return a.localeCompare((b), undefined, { numeric: true, sensitivity: 'base' })\n            })\n            .map(({ api }) => api)\n    }\n    get next() { return _navigate(this, +1) }\n    get prev() { return _navigate(this, -1) }\n    async preload() {\n        const filePromises = [\n            ...this.__file.layouts,\n            this.__file,\n            this.index && this.index.__file //if this is a layout, we want to include its index\n        ]\n            .filter(Boolean)\n            .map(file => file.component())\n        await Promise.all(filePromises)\n    }\n    get component() {\n        return this.__file.component ? //is file?\n            this.__file.component()\n            : this.__file.index ? //is dir with index?\n                this.__file.index.component()\n                : false\n    }\n    get componentWithIndex() {\n        return new Promise(resolve =>\n            Promise.all([\n                this.component,\n                this.index && this.index.component\n            ])\n                .then(res => resolve(res))\n        )\n    }\n    get index() {\n        const child = this.__file.children &&\n            this.__file.children.find(child => child.isIndex)\n        return child && child.api\n    }\n}\n\nfunction _navigate(node, direction) {\n    if (!node.__file.root) {\n        const siblings = node.parent.children\n        const index = siblings.indexOf(node)\n        return node.parent.children[index + direction]\n    }\n}\n\n\nfunction _prettyName(file) {\n    if (typeof file.meta.title !== 'undefined') return file.meta.title\n    else return (file.shortPath || file.path)\n        .split('/')\n        .pop()\n        .replace(/-/g, ' ')\n}\n\n","\n\nimport * as miscPlugins from './plugins/tree'\nimport { restoreDefaults } from './utils/normalizeNode'\nimport { assignAPI } from './plugins/assignAPI'\n\nconst plugins = {\n  ...miscPlugins,\n  restoreDefaults: ({ tree }) => restoreDefaults(tree),\n  assignAPI\n}\n\nexport function buildClientTree(tree) {\n  const order = [\n    // all\n    \"restoreDefaults\",\n    // pages\n    \"setParamKeys\", //pages only\n    \"setRegex\", //pages only\n    \"setShortPath\", //pages only\n    \"setRank\", //pages only\n    \"assignLayout\", //pages only,\n    // all\n    \"setPrototype\",\n    \"addMetaChildren\",\n    \"assignRelations\", //all (except meta components?)\n    \"setIsIndexable\", //all\n    \"assignIndex\", //all\n    \"assignAPI\", //all\n    // routes\n    \"createFlatList\"\n  ]\n\n  const payload = { tree, routes: [] }\n  for (let name of order) {\n    // if plugin is a createNodeMiddleware, use the sync function\n    const fn = plugins[name].sync || plugins[name]\n    fn(payload)\n  }\n  return payload\n}","\n/**\n * @roxi/routify 2.18.8\n * File generated Tue Oct 25 2022 22:44:25 GMT+0530 (India Standard Time)\n */\n\nexport const __version = \"2.18.8\"\nexport const __timestamp = \"2022-10-25T17:14:25.719Z\"\n\n//buildRoutes\nimport { buildClientTree } from \"@roxi/routify/runtime/buildRoutes\"\n\n//imports\n\n\n//options\nexport const options = {}\n\n//tree\nexport const _tree = {\n  \"root\": true,\n  \"children\": [\n    {\n      \"isFallback\": true,\n      \"path\": \"/_fallback\",\n      \"component\": () => import('../src/pages/_fallback.svelte').then(m => m.default)\n    },\n    {\n      \"isDir\": true,\n      \"children\": [\n        {\n          \"isIndex\": true,\n          \"isPage\": true,\n          \"meta\": {\n            \"$$bundleId\": \"_home__layout_svelte.js\",\n            \"recursive\": true,\n            \"preload\": false,\n            \"prerender\": true\n          },\n          \"path\": \"/home/index\",\n          \"id\": \"_home_index\",\n          \"component\": () => import('./_home__layout_svelte.js').then(m => m._home_index)\n        }\n      ],\n      \"isLayout\": true,\n      \"ownMeta\": {\n        \"bundle\": true\n      },\n      \"meta\": {\n        \"bundle\": true,\n        \"$$bundleId\": \"_home__layout_svelte.js\",\n        \"recursive\": true,\n        \"preload\": false,\n        \"prerender\": true\n      },\n      \"path\": \"/home\",\n      \"id\": \"_home__layout\",\n      \"component\": () => import('./_home__layout_svelte.js').then(m => m._home__layout)\n    },\n    {\n      \"isIndex\": true,\n      \"isPage\": true,\n      \"path\": \"/index\",\n      \"id\": \"_index\",\n      \"component\": () => import('../src/pages/index.svelte').then(m => m.default)\n    },\n    {\n      \"isDir\": true,\n      \"children\": [\n        {\n          \"isIndex\": true,\n          \"isPage\": true,\n          \"meta\": {\n            \"$$bundleId\": \"_order__layout_svelte.js\",\n            \"recursive\": true,\n            \"preload\": false,\n            \"prerender\": true\n          },\n          \"path\": \"/order/index\",\n          \"id\": \"_order_index\",\n          \"component\": () => import('./_order__layout_svelte.js').then(m => m._order_index)\n        }\n      ],\n      \"isLayout\": true,\n      \"ownMeta\": {\n        \"bundle\": true\n      },\n      \"meta\": {\n        \"bundle\": true,\n        \"$$bundleId\": \"_order__layout_svelte.js\",\n        \"recursive\": true,\n        \"preload\": false,\n        \"prerender\": true\n      },\n      \"path\": \"/order\",\n      \"id\": \"_order__layout\",\n      \"component\": () => import('./_order__layout_svelte.js').then(m => m._order__layout)\n    },\n    {\n      \"isDir\": true,\n      \"children\": [\n        {\n          \"isIndex\": true,\n          \"isPage\": true,\n          \"meta\": {\n            \"$$bundleId\": \"_overview__layout_svelte.js\",\n            \"recursive\": true,\n            \"preload\": false,\n            \"prerender\": true\n          },\n          \"path\": \"/overview/index\",\n          \"id\": \"_overview_index\",\n          \"component\": () => import('./_overview__layout_svelte.js').then(m => m._overview_index)\n        }\n      ],\n      \"isLayout\": true,\n      \"ownMeta\": {\n        \"bundle\": true\n      },\n      \"meta\": {\n        \"bundle\": true,\n        \"$$bundleId\": \"_overview__layout_svelte.js\",\n        \"recursive\": true,\n        \"preload\": false,\n        \"prerender\": true\n      },\n      \"path\": \"/overview\",\n      \"id\": \"_overview__layout\",\n      \"component\": () => import('./_overview__layout_svelte.js').then(m => m._overview__layout)\n    },\n    {\n      \"isDir\": true,\n      \"children\": [\n        {\n          \"isIndex\": true,\n          \"isPage\": true,\n          \"meta\": {\n            \"$$bundleId\": \"_price__layout_svelte.js\",\n            \"recursive\": true,\n            \"preload\": false,\n            \"prerender\": true\n          },\n          \"path\": \"/price/index\",\n          \"id\": \"_price_index\",\n          \"component\": () => import('./_price__layout_svelte.js').then(m => m._price_index)\n        }\n      ],\n      \"isLayout\": true,\n      \"ownMeta\": {\n        \"bundle\": true\n      },\n      \"meta\": {\n        \"bundle\": true,\n        \"$$bundleId\": \"_price__layout_svelte.js\",\n        \"recursive\": true,\n        \"preload\": false,\n        \"prerender\": true\n      },\n      \"path\": \"/price\",\n      \"id\": \"_price__layout\",\n      \"component\": () => import('./_price__layout_svelte.js').then(m => m._price__layout)\n    }\n  ],\n  \"isLayout\": true,\n  \"path\": \"/\",\n  \"id\": \"__layout\",\n  \"component\": () => import('../src/pages/_layout.svelte').then(m => m.default)\n}\n\n\nexport const {tree, routes} = buildClientTree(_tree)\n\n","<script>\n  export let scoped = {};\n  scoped;\n</script>\n\n<slot/>\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { writable, derived } from 'svelte/store'\nimport '../typedef'\n\nwindow.routify = window.routify || {}\n\n/** @type {import('svelte/store').Writable<RouteNode>} */\nexport const route = writable(null) // the actual route being rendered\n\n/** @type {import('svelte/store').Writable<RouteNode[]>} */\nexport const routes = writable([]) // all routes\nroutes.subscribe(routes => (window.routify.routes = routes))\n\nexport let rootContext = writable({ component: { params: {} } })\n\n/** @type {import('svelte/store').Writable<RouteNode>} */\nexport const urlRoute = writable(null)  // the route matching the url\n\nexport const prefetchPath = writable(\"\")\n\nexport const isChangingPage = writable(true)","import { currentLocation, handleScroll } from './index'\n\n\nexport async function onPageLoaded({ page, metatags, afterPageLoad, parentNode }) {\n    //scroll needs to run after page load\n    const scrollToTop = page.last !== page\n    setTimeout(() => handleScroll(parentNode, scrollToTop))\n\n    const { path } = page\n    const { options } = currentLocation()\n    const prefetchId = options.prefetch\n\n    for (const hook of afterPageLoad._hooks) {\n        // deleted/invalidated hooks are left as undefined\n        if (hook) await hook(page.api)\n    }\n\n    metatags.update()\n\n    dispatchEvent(new CustomEvent('app-loaded'))\n    parent.postMessage({\n        msg: 'app-loaded',\n        prefetched: window.routify.prefetched,\n        path,\n        prefetchId\n    }, \"*\")\n    window['routify'].appLoaded = true\n    window['routify'].stopAutoReady = false\n}\n","import { get } from 'svelte/store'\nimport * as stores from '../store'\nimport config from '../../runtime.config'\nimport { parseUrl, resolveUrl } from './index'\n\n/**\n * @param {string} url \n * @return {ClientNode}\n */\nexport function urlToRoute(url, clone = false) {\n    url = config.urlTransform.remove(url)\n    let { pathname, search } = parseUrl(url).url\n\n    /** @type {RouteNode[]} */\n    const routes = get(stores.routes)\n    const matchingRoute =\n        // find a route with a matching name\n        routes.find(route => pathname === route.meta.name) ||\n        // or a matching path\n        routes.find(route => pathname.match(route.regex))\n\n    if (!matchingRoute)\n        throw new Error(`Route could not be found for \"${pathname}\".`)\n\n    // we want to clone if we're only previewing an URL\n    const _matchingRoute = clone ? Object.create(matchingRoute) : matchingRoute\n\n    const { route, redirectPath, rewritePath } = resolveRedirects(_matchingRoute, routes)\n\n    if (rewritePath) {\n        ({ pathname, search } = parseUrl(resolveUrl(rewritePath, route.params)).url)\n        if (redirectPath)\n            route.redirectTo = resolveUrl(redirectPath, route.params || {});\n    }\n\n    if (config.queryHandler)\n        route.params = Object.assign({}, config.queryHandler.parse(search))\n\n    assignParamsToRouteAndLayouts(route, pathname)\n\n    route.leftover = url.replace(new RegExp(route.regex), '')\n    return route\n}\n\nfunction assignParamsToRouteAndLayouts(route, pathname) {\n    if (route.paramKeys) {\n        const layouts = layoutByPos(route.layouts)\n        const fragments = pathname.split('/').filter(Boolean)\n        const routeProps = getRouteProps(route.path)\n\n        routeProps.forEach((prop, i) => {\n            if (prop) {\n                route.params[prop] = fragments[i]\n                if (layouts[i]) layouts[i].param = { [prop]: fragments[i] }\n                else route.param = { [prop]: fragments[i] }\n            }\n        })\n    }\n}\n\n/**\n * \n * @param {RouteNode} route \n * @param {RouteNode[]} routes \n * @param {*} params \n */\nfunction resolveRedirects(route, routes, redirectPath, rewritePath) {\n    const { redirect, rewrite } = route.meta\n\n    if (redirect || rewrite) {\n        redirectPath = redirect ? redirect.path || redirect : redirectPath\n        rewritePath = rewrite ? rewrite.path || rewrite : redirectPath\n        const redirectParams = redirect && redirect.params\n        const rewriteParams = rewrite && rewrite.params\n\n        const newRoute = routes.find(r => r.path.replace(/\\/index$/,'') === rewritePath)\n\n        if (newRoute === route) console.error(`${rewritePath} is redirecting to itself`)\n        if (!newRoute) console.error(`${route.path} is redirecting to non-existent path: ${rewritePath}`)\n        if (redirectParams || rewriteParams)\n            newRoute.params = Object.assign({}, newRoute.params, redirectParams, rewriteParams)\n\n        return resolveRedirects(newRoute, routes, redirectPath, rewritePath)\n    }\n    return { route, redirectPath, rewritePath }\n}\n\n\n/**\n * @param {array} layouts\n */\nfunction layoutByPos(layouts) {\n    const arr = []\n    layouts.forEach(layout => {\n        arr[layout.path.split('/').filter(Boolean).length - 1] = layout\n    })\n    return arr\n}\n\n\n/**\n * @param {string} url\n */\nfunction getRouteProps(url) {\n    return url\n        .split('/')\n        .filter(Boolean)\n        .map(f => f.match(/\\:(.+)/))\n        .map(f => f && f[1])\n}\n","<script context=\"module\">\n  import { writable, derived, get } from 'svelte/store'\n\n  /** config */\n  const iframeNum = 2\n  const defaults = {\n    validFor: 60,\n    timeout: 5000,\n    gracePeriod: 1000,\n  }\n\n  /** stores and subscriptions */\n  const queue = writable([])\n  const actives = derived(queue, q => q.slice(0, iframeNum))\n  actives.subscribe(actives =>\n    actives.forEach(({ options }) => {\n      setTimeout(() => removeFromQueue(options.prefetch), options.timeout)\n    })\n  )\n\n  /**\n   * @param {string} path\n   * @param {defaults} options\n   */\n  export function prefetch(path, options = {}) {\n    prefetch.id = prefetch.id || 1\n    path = path.href || path\n\n    options = { ...defaults, ...options }\n    options.prefetch = prefetch.id++\n\n    //don't prefetch within prefetch or SSR\n    if (window.routify.prefetched || navigator.userAgent.match('jsdom'))\n      return false\n\n    // add to queue\n    queue.update(q => {\n      if (!q.some(e => e.options.path === path))\n        q.push({\n          url: `${path}__[[routify_url_options]]__${encodeURIComponent(JSON.stringify(options))}`,\n          options,\n        })\n      return q\n    })\n  }\n\n  /**\n   * @param {number|MessageEvent} idOrEvent\n   */\n  function removeFromQueue(idOrEvent) {\n    const id = idOrEvent.data ? idOrEvent.data.prefetchId : idOrEvent\n    if (!id) return null\n\n    const entry = get(queue).find(\n      entry => entry && entry.options.prefetch == id\n    )\n    // removeFromQueue is called by both eventListener and timeout,\n    // but we can only remove the item once\n    if (entry) {\n      const { gracePeriod } = entry.options\n      const gracePromise = new Promise(resolve =>\n        setTimeout(resolve, gracePeriod)\n      )\n      const idlePromise = new Promise(resolve => {\n        window.requestIdleCallback\n          ? window.requestIdleCallback(resolve)\n          : setTimeout(resolve, gracePeriod + 1000)\n      })\n      Promise.all([gracePromise, idlePromise]).then(() => {\n        queue.update(q => q.filter(q => q.options.prefetch != id))\n      })\n    }\n  }\n\n  // Listen to message from child window\n  addEventListener('message', removeFromQueue, false)\n</script>\n\n<div id=\"__routify_iframes\" style=\"display: none\">\n  {#each $actives as prefetch (prefetch.options.prefetch)}\n    <iframe src={prefetch.url} frameborder=\"0\" title=\"routify prefetcher\" />\n  {/each}\n</div>\n","import {getContext, tick} from 'svelte'\nimport {derived, get, writable} from 'svelte/store'\nimport {route, routes, rootContext, isChangingPage} from './store'\nimport {resolveUrl} from './utils'\nimport {onPageLoaded} from './utils/onPageLoaded.js'\nimport {urlToRoute} from './utils/urlToRoute'\nimport {prefetch as _prefetch} from './Prefetcher.svelte'\n/// <reference path=\"../typedef.js\" />\n\n/** @ts-check */\n/**\n * @typedef {Object} RoutifyContext\n * @prop {ClientNode} component\n * @prop {ClientNode} layout\n * @prop {any} componentFile \n * \n *  @returns {import('svelte/store').Readable<RoutifyContext>} */\nfunction getRoutifyContext() {\n  return getContext('routify') || rootContext\n}\n\nexport const nodes = {\n  subscribe(run) {\n    const nodes = []\n    return derived(routes, routes => {\n      routes.forEach(route => {\n        const layouts = route.layouts\n          .map(layout => layout.api)\n          .filter(api => !nodes.includes(api))\n        nodes.push(route.api, ...layouts)\n      })\n\n      // enhance find method\n      const find = nodes.find\n      nodes.find = (value, ...args) => {\n        // if value is string, return route which name or path matches value\n        if (typeof value === 'string')\n          return nodes.find(n => n.meta.name === value) ||\n            nodes.find(n => n.path === value)\n        // or default to Array.find\n        else return find.bind(nodes)(value, ...args)\n      }\n\n      return nodes\n    }).subscribe(run)\n  }\n}\n\nexport const components = nodes\n\n/**\n * @typedef {import('svelte/store').Readable<ClientNodeApi>} ClientNodeHelperStore\n * @type { ClientNodeHelperStore } \n */\nexport const page = {\n  subscribe(run) {\n    return derived(route, route => route.api).subscribe(run)\n  }\n}\n\n/** @type {ClientNodeHelperStore} */\nexport const node = {\n  subscribe(run) {\n    const ctx = getRoutifyContext()\n    return derived(ctx, ctx => ctx.component.api).subscribe(run)\n  }\n}\n\n/** @type {ClientNodeHelperStore} */\nexport const layout = {\n  subscribe(run) {\n    const ctx = getRoutifyContext()\n    return derived(ctx, ctx => ctx.layout.api).subscribe(run)\n  }\n}\n\n/**\n* @typedef {{component: ClientNode}}  ContextHelper\n* @typedef {import('svelte/store').Readable<ContextHelper>} ContextHelperStore\n* @type {ContextHelperStore}\n*/\nexport const context = {\n  subscribe(run) {\n    return getRoutifyContext().subscribe(run)\n  }\n}\n\n/**\n * @typedef {function():void} ReadyHelper\n * @typedef {import('svelte/store').Readable<ReadyHelper>} ReadyHelperStore\n * @type {ReadyHelperStore}\n*/\nexport const ready = {\n  subscribe(run) {\n    window['routify'].stopAutoReady = true\n    async function ready() {\n      await tick()\n      await onPageLoaded({page: get(route), metatags, afterPageLoad})\n    }\n    run(ready)\n    return () => {}\n  }\n}\n\n/**\n * @callback AfterPageLoadHelper\n * @param {function} callback\n * \n * @typedef {import('svelte/store').Readable<AfterPageLoadHelper> & {_hooks:Array<function>}} AfterPageLoadHelperStore\n * @type {AfterPageLoadHelperStore}\n */\nexport const afterPageLoad = {\n  _hooks: [\n    event => isChangingPage.set(false)\n  ],\n  subscribe: hookHandler\n}\n\n/** \n * @callback BeforeUrlChangeHelper\n * @param {function} callback\n *\n * @typedef {import('svelte/store').Readable<BeforeUrlChangeHelper> & {_hooks:Array<function>}} BeforeUrlChangeHelperStore\n * @type {BeforeUrlChangeHelperStore}\n **/\nexport const beforeUrlChange = {\n  _hooks: [],\n  subscribe: hookHandler\n}\n\nfunction hookHandler(listener) {\n  const hooks = this._hooks\n  const index = hooks.length\n  listener(callback => {hooks[index] = callback})\n  return (...params) => {\n    delete hooks[index]\n    listener(...params)\n  }\n}\n\n/**\n * We have to grab params and leftover from the context and not directly from the store.\n * Otherwise the context is updated before the component is destroyed. * \n * @typedef {Object.<string, *>} ParamsHelper\n * @typedef {import('svelte/store').Readable<ParamsHelper>} ParamsHelperStore\n * @type {ParamsHelperStore}\n **/\nexport const params = {\n  subscribe(run) {\n    const ctx = getRoutifyContext()\n    return derived(ctx, ctx => ctx.route.params).subscribe(run)\n  }\n}\n\n/**\n * @typedef {string} LeftoverHelper\n * @typedef {import('svelte/store').Readable<string>} LeftoverHelperStore\n * @type {LeftoverHelperStore} \n **/\nexport const leftover = {\n  subscribe(listener) {\n    return derived(\n      route,\n      route => route.leftover\n    ).subscribe(listener)\n  },\n}\n\n/** * \n * @param {ClientNodeApi} descendant \n * @param {ClientNodeApi} ancestor \n * @param {boolean} treatIndexAsAncestor \n */\nexport function isAncestor(ancestor, descendant, treatIndexAsAncestor = true) {\n  ancestor = ancestor.__file || ancestor\n  descendant = descendant.__file || descendant\n  const siblings = descendant.parent === ancestor.parent\n\n  if (!ancestor.isIndex) return false\n  if (descendant.shortPath === ancestor.shortPath) return false\n\n  if (siblings && !descendant.isDir) return !!treatIndexAsAncestor\n  return descendant.shortPath.startsWith(ancestor.shortPath)\n}\n\n\n/**\n * @typedef {import('svelte/store').Readable<Meta>} MetaHelperStore \n * @type {MetaHelperStore}\n * */\nexport const meta = {\n  subscribe(listener) {\n    const ctx = getRoutifyContext()\n    return derived(ctx, ctx => ctx.layout.meta).subscribe(listener)\n  },\n}\n\n/**\n * @typedef {{\n *   (el: Node): {update: (args: any) => void;}\n *   (path?: string | undefined, params?: UrlParams | undefined, options?: UrlOptions | undefined): string;\n * }} UrlHelper\n * @typedef {import('svelte/store').Readable<UrlHelper>} UrlHelperStore\n * @type {UrlHelperStore} \n * */\nexport const url = {\n  subscribe(listener) {\n    const ctx = getRoutifyContext()\n    return derived(\n      ctx,\n      ctx => makeUrlHelper(ctx, ctx.route, ctx.routes)\n    ).subscribe(\n      listener\n    )\n  }\n}\n\n/** \n * @param {{component: ClientNode}} $ctx \n * @param {RouteNode} $currentRoute \n * @param {RouteNode[]} $routes \n * @returns {UrlHelper}\n */\nexport function makeUrlHelper($ctx, $currentRoute, $routes) {\n  return function url(path, params = {}, options) {\n    const {component} = $ctx\n    const inheritedParams = Object.assign({}, $currentRoute.params, component.params)\n    let el = path && path.nodeType && path\n\n    if (el)\n      path = path.getAttribute('href')\n\n    path = path ? resolvePath(path) : component.shortPath\n\n    // preload the route  \n    const route = $routes.find(route => [route.shortPath || '/', route.path].includes(path))\n    if (route && route.meta.preload === 'proximity' && window.requestIdleCallback) {\n      const delay = routify.appLoaded ? 0 : 1500\n      setTimeout(() => {\n        window.requestIdleCallback(() => route.api.preload())\n      }, delay)\n    }\n\n    const strict = options && options.strict !== false\n    if (!strict) path = path.replace(/index$/, '')\n\n    let url = resolveUrl(path, params, inheritedParams)\n\n    if (el) {\n      el.href = url\n      return {\n        update(changedParams) {el.href = resolveUrl(path, changedParams, inheritedParams)}\n      }\n    }\n\n    return url\n\n    /**\n     * converts relative, named and absolute paths to absolute paths\n     * example: at `/foo/bar/baz`  the path  `../bar2/:something`  converts to   `/foo/bar2/:something`\n     * @param {*} path \n     */\n    function resolvePath(path) {\n      if (path.match(/^\\.\\.?\\//)) {\n        //RELATIVE PATH\n        let [, breadcrumbs, relativePath] = path.match(/^([\\.\\/]+)(.*)/)\n        let dir = component.path.replace(/\\/$/, '')\n        const traverse = breadcrumbs.match(/\\.\\.\\//g) || []\n        // if this is a page, we want to traverse one step back to its folder\n        if (component.isPage) traverse.push(null)\n        traverse.forEach(() => dir = dir.replace(/\\/[^\\/]+\\/?$/, ''))\n        path = `${dir}/${relativePath}`.replace(/\\/$/, '')\n        path = path || '/' // empty means root\n      } else if (path.match(/^\\//)) {\n        // ABSOLUTE PATH\n      } else {\n        // NAMED PATH\n        const matchingRoute = $routes.find(route => route.meta.name === path)\n        if (matchingRoute) path = matchingRoute.shortPath\n      }\n      return path\n    }\n\n\n\n  }\n}\n\n\n/**\n* @callback GotoHelper\n* @param {String=} path\n* @param {UrlParams=} params\n* @param {GotoOptions=} options\n*\n* @typedef {import('svelte/store').Readable<GotoHelper>}  GotoHelperStore\n* @type {GotoHelperStore} \n* */\nexport const goto = {\n  subscribe(listener) {\n    const routifyUpdatePage = getContext('routifyupdatepage')\n    return derived(url,\n      url => function goto(path, params, _static, shallow) {\n        const href = url(path, params)\n        if (!_static) history.pushState({}, null, href)\n        else routifyUpdatePage(href, shallow)\n      }\n    ).subscribe(\n      listener\n    )\n  },\n}\n\n/**\n * @type {GotoHelperStore} \n * */\nexport const redirect = {\n  subscribe(listener) {\n    const routifyUpdatePage = getContext('routifyupdatepage')\n    return derived(url,\n      url => function redirect(path, params, _static, shallow) {\n        const href = url(path, params)\n        if (!_static) history.replaceState({}, null, href)\n        else routifyUpdatePage(href, shallow)\n      }\n    ).subscribe(\n      listener\n    )\n  },\n}\n\n/**\n * @callback IsActiveHelper\n * @param {String=} path\n * @param {UrlParams=} params\n * @param {UrlOptions=} options\n * @returns {Boolean}\n * \n * @typedef {import('svelte/store').Readable<IsActiveHelper>} IsActiveHelperStore\n * @type {IsActiveHelperStore} \n * */\nexport const isActive = {\n  subscribe(run) {\n    return derived(\n      [url, route],\n      ([url, route]) => function isActive(path = \"\", params = {}, {strict} = {strict: true}) {\n        path = url(path, params, {strict})\n        const currentPath = url(route.path, params, {strict})\n        const re = new RegExp('^' + path + '($|/)')\n        return !!currentPath.match(re)\n      }\n    ).subscribe(run)\n  },\n}\n\n/**\n * @param {string|ClientNodeApi} path \n * @param {*} options \n */\nexport function precache(path, options) {\n  const node = typeof path === 'string' ? urlToRoute(path) : path\n  node.component()\n}\n\n/**\n * @param {string|ClientNodeApi} path \n * @param {*} options \n */\nexport function prefetch(path, options) {\n  _prefetch(path, options)\n}\n\n/**\n * @typedef {[ClientNodeApi, ClientNodeApi, ClientNodeApi]} ConcestorReturn\n * @typedef {function(ClientNodeApi, ClientNodeApi):ConcestorReturn} GetConcestor\n * @type {GetConcestor}\n */\nexport function getConcestor(nodeApi1, nodeApi2) {\n  const node1 = nodeApi1.__file\n  const node2 = nodeApi2.__file\n\n  // The route is the last piece of layout\n  const lineage1 = [...node1.lineage, node1]\n  const lineage2 = [...node2.lineage, node2]\n\n  let concestor = lineage1[0] //root\n  let children = [lineage1[0].api, lineage2[0].api]\n  // iterate through the layouts starting from the root\n  lineage1.forEach((n1, i) => {\n    const n2 = lineage2[i]\n    if (n2 && n1.parent === n2.parent) {\n      concestor = n1.parent\n      children = [n1.api, n2.api]\n    }\n  })\n  return [concestor.api, children[0], children[1]]\n}\n\n/**\n * Get index difference between two paths\n *\n * @export\n * @param {array} paths\n * @param {object} newPath\n * @param {object} oldPath\n * @returns {number}\n */\nexport function getDirection(paths, newPath, oldPath) {\n  const newIndex = paths.findIndex(path => newPath.path.startsWith(path))\n  const oldIndex = paths.findIndex(path => oldPath.path.startsWith(path))\n  return newIndex - oldIndex\n}\n\n/**\n * Sets element to active\n * @typedef {function(HTMLElement):void} FocusHelper\n * @type {FocusHelper}\n */\nexport function focus(element) {\n  if (!focusIsSet) {\n    focusIsSet = true\n    element.setAttribute('tabindex', \"0\")\n    element.focus()\n    setTimeout(() => (focusIsSet = false))\n  }\n}\nlet focusIsSet = false\n\n\n\nconst _metatags = {\n  subscribe(listener) {\n    this._origin = this.getOrigin()\n    return listener(metatags)\n  },\n  props: {},\n  templates: {},\n  services: {\n    plain: {propField: 'name', valueField: 'content'},\n    twitter: {propField: 'name', valueField: 'content'},\n    og: {propField: 'property', valueField: 'content'},\n  },\n  plugins: [\n    {\n      name: 'applyTemplate',\n      condition: () => true,\n      action: (prop, value) => {\n        const template = _metatags.getLongest(_metatags.templates, prop) || (x => x)\n        return [prop, template(value)]\n      }\n    },\n    {\n      name: 'createMeta',\n      condition: () => true,\n      action(prop, value) {\n        _metatags.writeMeta(prop, value)\n      }\n    },\n    {\n      name: 'createOG',\n      condition: prop => !prop.match(':'),\n      action(prop, value) {\n        _metatags.writeMeta(`og:${prop}`, value)\n      }\n    },\n    {\n      name: 'createTitle',\n      condition: prop => prop === 'title',\n      action(prop, value) {\n        document.title = value;\n      }\n    }\n  ],\n  getLongest(repo, name) {\n    const providers = repo[name]\n    if (providers) {\n      const currentPath = get(route).path\n      const allPaths = Object.keys(repo[name])\n      const matchingPaths = allPaths.filter(path => currentPath.includes(path))\n\n      const longestKey = matchingPaths.sort((a, b) => b.length - a.length)[0]\n\n      return providers[longestKey]\n    }\n  },\n  writeMeta(prop, value) {\n    const head = document.getElementsByTagName('head')[0]\n    const match = prop.match(/(.+)\\:/)\n    const serviceName = match && match[1] || 'plain'\n    const {propField, valueField} = metatags.services[serviceName] || metatags.services.plain\n    const oldElement = document.querySelector(`meta[${propField}='${prop}']`)\n    if (oldElement) oldElement.remove()\n\n    const newElement = document.createElement('meta')\n    newElement.setAttribute(propField, prop)\n    newElement.setAttribute(valueField, value)\n    newElement.setAttribute('data-origin', 'routify')\n    head.appendChild(newElement)\n  },\n  set(prop, value) {\n    // we only want strings. If metatags is used as a store, svelte will try to assign an object to prop\n    if (typeof prop === 'string') {\n      _metatags.plugins.forEach(plugin => {\n        if (plugin.condition(prop, value))\n          [prop, value] = plugin.action(prop, value) || [prop, value]\n      })\n    }\n  },\n  clear() {\n    const oldElement = document.querySelector(`meta`)\n    if (oldElement) oldElement.remove()\n  },\n  template(name, fn) {\n    const origin = _metatags.getOrigin\n    _metatags.templates[name] = _metatags.templates[name] || {}\n    _metatags.templates[name][origin] = fn\n  },\n  update() {\n    Object.keys(_metatags.props).forEach((prop) => {\n      let value = (_metatags.getLongest(_metatags.props, prop))\n      _metatags.plugins.forEach(plugin => {\n        if (plugin.condition(prop, value)) {\n          [prop, value] = plugin.action(prop, value) || [prop, value]\n\n        }\n      })\n    })\n  },\n  batchedUpdate() {\n    if (!_metatags._pendingUpdate) {\n      _metatags._pendingUpdate = true\n      setTimeout(() => {\n        _metatags._pendingUpdate = false\n        this.update()\n      })\n    }\n  },\n  _updateQueued: false,\n  _origin: false,\n  getOrigin() {\n    if (this._origin) return this._origin\n    const routifyCtx = getRoutifyContext()\n    return routifyCtx && get(routifyCtx).path || '/'\n  },\n  _pendingUpdate: false\n}\n\n\n/**\n * metatags\n * @prop {Object.<string, string>}\n */\nexport const metatags = new Proxy(_metatags, {\n  set(target, name, value, receiver) {\n    const {props} = target\n\n    if (Reflect.has(target, name))\n      Reflect.set(target, name, value, receiver)\n    else {\n      props[name] = props[name] || {}\n      props[name][target.getOrigin()] = value\n    }\n\n    if (window['routify'].appLoaded)\n      target.batchedUpdate()\n    return true\n  }\n})","<script>\n  // @ts-check\n  /** @typedef {{component():*, path: string, isLayout: false, param: false}} Decorator */\n  /** @typedef {ClientNode | Decorator} LayoutOrDecorator */\n  /**\n   * @typedef {Object} Context\n   * @prop {ClientNode} layout\n   * @prop {ClientNode} component\n   * @prop {LayoutOrDecorator} child\n   * @prop {SvelteComponent} ComponentFile\n   * @prop {HTMLElement} parentNode\n   * */\n\n  import { suppressComponentWarnings } from './utils'\n  import Noop from './decorators/Noop.svelte'\n  import '../typedef.js'\n  import { getContext, setContext, tick } from 'svelte'\n  import { writable } from 'svelte/store'\n  import { metatags, afterPageLoad } from './helpers.js'\n  import { route, routes, rootContext } from './store'\n  import { handleScroll } from './utils'\n  import { onPageLoaded } from './utils/onPageLoaded.js'\n\n  /** @type {LayoutOrDecorator[]} */\n  export let nodes = []\n  export let scoped = {}\n  export let decorator = undefined\n\n  /** @type {LayoutOrDecorator} */\n  let node = null\n  let remainingNodes = null\n  let scopedSync = {}\n  let parentNode\n  let invalidate = 1\n\n  const context = writable(null)\n  /** @type {import(\"svelte/store\").Writable<Context>} */\n  const parentContext = getContext('routify') || rootContext\n  const setParentNode = (el) => parentNode = el.parentNode\n  \n  setContext('routify', context)\n\n  let lastNodes = []\n  $: if (lastNodes !== nodes) {\n    lastNodes = nodes\n    ;[node, ...remainingNodes] = [...nodes]\n    node['api'].reset = () => invalidate++\n  }\n\n  /**  @param {LayoutOrDecorator} node */\n  function setComponent(node) {\n    let PendingComponent = node.component()\n    if (PendingComponent instanceof Promise)\n      PendingComponent.then(onComponentLoaded)\n    else onComponentLoaded(PendingComponent)\n  }\n  $: setComponent(node)\n\n  /** @param {SvelteComponent} componentFile */\n  function onComponentLoaded(componentFile) {\n    scopedSync = { ...scoped }\n\n    // we have to proxy remaining nodes through ctx (instead of props) or route changes get propagated\n    // to leaf layouts of to-be-destroyed-layouts\n    const ctx = {\n      //we need to keep any possible context.child or the layout will be childless until the new child has been rendered\n      ...$context,\n      nodes: remainingNodes,\n      decorator: decorator || Noop,\n      layout: node.isLayout ? node : $parentContext.layout,\n      component: node,\n      route: $route,\n      routes: $routes,\n      componentFile,\n      parentNode: parentNode || $parentContext.parentNode,\n    }\n    context.set(ctx)\n    $parentContext.child = node\n    if (remainingNodes.length === 0) onLastComponentLoaded()\n  }\n\n  async function onLastComponentLoaded() {\n    await new Promise((resolve) => setTimeout(resolve))\n    const isOnCurrentRoute = $context.component.path === $route.path //maybe we're getting redirected\n\n    // Let everyone know the last child has rendered\n    if (!window['routify'].stopAutoReady && isOnCurrentRoute)\n      onPageLoaded({\n        page: $context.component,\n        metatags,\n        afterPageLoad,\n        parentNode,\n      })\n  }\n\n  /**  @param {ClientNode} layout */\n  function getID({ meta, path, param, params }) {\n    return JSON.stringify({\n      path,\n      invalidate,\n      param: (meta['param-is-page'] || meta['slug-is-page']) && param,\n      queryParams: meta['query-params-is-page'] && params,\n    })\n  }\n  $: id = $context && invalidate && getID($context.component)\n  $: $context && suppressComponentWarnings($context, tick)\n</script>\n\n{#if $context}\n  {#each [$context] as { component, componentFile, decorator, nodes } (id)}\n    <svelte:component this={decorator} {scoped}>\n      <svelte:component\n        this={componentFile}\n        let:scoped={scopeToChild}\n        let:decorator\n        {scoped}\n        {scopedSync}\n        {...node.param || {}}\n      >\n        {#if component && nodes.length}\n          <svelte:self\n            {decorator}\n            {nodes}\n            scoped={{ ...scoped, ...scopeToChild }}\n          />\n        {/if}\n      </svelte:component>\n    </svelte:component>\n  {/each}\n{/if}\n<!-- get the parent element for scroll and transitions -->\n\n{#if !parentNode}\n  <div style=\"display: contents\" use:setParentNode />\n{/if}\n","import * as stores from './store'\nimport { get } from 'svelte/store'\nimport { beforeUrlChange } from './helpers'\nimport { urlToRoute } from './utils/urlToRoute'\nimport { currentLocation } from './utils'\n\nexport function init(routes, callback) {\n  /** @type { ClientNode | false } */\n  let lastRoute = false\n\n  function updatePage(proxyToUrl, shallow) {\n    const url = proxyToUrl || currentLocation().fullpath\n    const route = urlToRoute(url)\n    if (route.redirectTo) {\n      history.replaceStateNative({}, null, route.redirectTo)\n      delete route.redirectTo\n    }\n\n    const currentRoute = shallow && urlToRoute(currentLocation().fullpath, routes)\n    const contextRoute = currentRoute || route\n    const nodes = [...contextRoute.layouts, route]\n    if (lastRoute) delete lastRoute.last //todo is a page component the right place for the previous route?\n    route.last = lastRoute\n    lastRoute = route\n\n    //set the route in the store\n    if (!proxyToUrl)\n      stores.urlRoute.set(route)\n    stores.route.set(route)\n\n    //preload components in parallel\n    route.api.preload().then(() => {\n      //run callback in Router.svelte    \n      stores.isChangingPage.set(true)\n      callback(nodes)\n    })\n  }\n\n  const destroy = createEventListeners(updatePage)\n\n  return { updatePage, destroy }\n}\n\n/**\n * svelte:window events doesn't work on refresh\n * @param {Function} updatePage\n */\nfunction createEventListeners(updatePage) {\n  // history.*state\n  ;['pushState', 'replaceState'].forEach(eventName => {\n    if (!history[eventName + 'Native'])\n      history[eventName + 'Native'] = history[eventName]\n    history[eventName] = async function (state = {}, title, url) {\n      // do nothing if we're navigating to the current page\n      const currentUrl = location.pathname + location.search + location.hash\n      if (url === currentUrl) return false\n\n      const { id, path, params } = get(stores.route)\n      state = { id, path, params, ...state }\n      const event = new Event(eventName.toLowerCase())\n      Object.assign(event, { state, title, url })\n\n      const route = await runHooksBeforeUrlChange(event, url)\n      if (route) {\n        history[eventName + 'Native'].apply(this, [state, title, url])\n        return dispatchEvent(event)\n      }\n    }\n  })\n\n  let _ignoreNextPop = false\n\n  const listeners = {\n    click: handleClick,\n    pushstate: () => updatePage(),\n    replacestate: () => updatePage(),\n    popstate: async event => {\n      if (_ignoreNextPop)\n        _ignoreNextPop = false\n      else {\n        if (await runHooksBeforeUrlChange(event, currentLocation().fullpath)) {\n          updatePage()\n        } else {\n          _ignoreNextPop = true\n          event.preventDefault()\n          history.go(1)\n        }\n      }\n    },\n  }\n\n  Object.entries(listeners).forEach(args => addEventListener(...args))\n\n  const unregister = () => {\n    Object.entries(listeners).forEach(args => removeEventListener(...args))\n  }\n\n  return unregister\n}\n\nfunction handleClick(event) {\n  const el = event.target.closest('a') || event.composedPath().find(el => el.tagName === 'A')\n  const href = el && el.href\n  if (\n    event.ctrlKey ||\n    event.metaKey ||\n    event.altKey ||\n    event.shiftKey ||\n    event.button ||\n    event.defaultPrevented\n  )\n    return\n  if (!href || el.target || el.host !== location.host) return\n\n  const url = new URL(href)\n  const relativeUrl = url.pathname + url.search + url.hash\n\n  event.preventDefault()\n  history.pushState({}, '', relativeUrl)\n}\n\nasync function runHooksBeforeUrlChange(event, url) {\n  const route = urlToRoute(url).api\n  for (const hook of beforeUrlChange._hooks.filter(Boolean)) {\n    // return false if the hook returns false\n    const result = await hook(event, route, { url })\n    if (!result) return false\n  }\n  return true\n}\n\n","<script>\n  import { setContext, onDestroy } from 'svelte'\n  import Route from './Route.svelte'\n  import Prefetcher from './Prefetcher.svelte'\n  import { init } from './navigator.js'\n  import { route, routes as routesStore } from './store.js'\n  import defaultConfig from '../runtime.config'\n\n  export let routes\n  export let config = {}\n\n  let nodes\n  let navigator\n\n  window.routify = window.routify || {}\n  window.routify.inBrowser = !window.navigator.userAgent.match('jsdom')\n\n  Object.assign(defaultConfig, config)\n\n  const updatePage = (...args) => navigator && navigator.updatePage(...args)\n\n  setContext('routifyupdatepage', updatePage)\n\n  const callback = res => (nodes = res)\n\n  const cleanup = () => {\n    if (!navigator) return\n    navigator.destroy()\n    navigator = null\n  }\n\n  let initTimeout = null\n\n  // init is async to prevent a horrible bug that completely disable reactivity\n  // in the host component -- something like the component's update function is\n  // called before its fragment is created, and since the component is then seen\n  // as already dirty, it is never scheduled for update again, and remains dirty\n  // forever... I failed to isolate the precise conditions for the bug, but the\n  // faulty update is triggered by a change in the route store, and so offseting\n  // store initialization by one tick gives the host component some time to\n  // create its fragment. The root cause it probably a bug in Svelte with deeply\n  // intertwinned store and reactivity.\n  const doInit = () => {\n    clearTimeout(initTimeout)\n    initTimeout = setTimeout(() => {\n      cleanup()\n      navigator = init(routes, callback)\n      routesStore.set(routes)\n      navigator.updatePage()\n    })\n  }\n\n  $: if (routes) doInit()\n\n  onDestroy(cleanup)\n</script>\n\n{#if nodes && $route !== null}\n  <Route {nodes} />\n{/if}\n\n<Prefetcher />\n","import './app.css';\nimport App from './App.svelte';\n\nconst app = new App({\n  target: document.getElementById('app')\n})\n\nexport default app\n"],"file":"assets/index.a920b4c2.js"}